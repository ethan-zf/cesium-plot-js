{"version":3,"file":"OrientedBoundingBox-7e2eebab.js","sources":["../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Interval from \"./Interval.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Matrix4 from \"./Matrix4.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * Creates an instance of an OrientedBoundingBox.\r\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n * @alias OrientedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n *                                          cube centered at the origin.\r\n *\r\n *\r\n * @example\r\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n *\r\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction OrientedBoundingBox(center, halfAxes) {\r\n  /**\r\n   * The center of the box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n  /**\r\n   * The transformation matrix, to rotate the box to the right position.\r\n   * @type {Matrix3}\r\n   * @default {@link Matrix3.ZERO}\r\n   */\r\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrientedBoundingBox.packedLength =\r\n  Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrientedBoundingBox} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Cartesian3.pack(value.center, array, startingIndex);\r\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  Cartesian3.unpack(array, startingIndex, result.center);\r\n  Matrix3.unpack(\r\n    array,\r\n    startingIndex + Cartesian3.packedLength,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\nconst scratchCartesian1 = new Cartesian3();\r\nconst scratchCartesian2 = new Cartesian3();\r\nconst scratchCartesian3 = new Cartesian3();\r\nconst scratchCartesian4 = new Cartesian3();\r\nconst scratchCartesian5 = new Cartesian3();\r\nconst scratchCartesian6 = new Cartesian3();\r\nconst scratchCovarianceResult = new Matrix3();\r\nconst scratchEigenResult = {\r\n  unitary: new Matrix3(),\r\n  diagonal: new Matrix3(),\r\n};\r\n\r\n/**\r\n * Computes an instance of an OrientedBoundingBox of the given positions.\r\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n *\r\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an object oriented bounding box enclosing two points.\r\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nOrientedBoundingBox.fromPoints = function (positions, result) {\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  if (!defined(positions) || positions.length === 0) {\r\n    result.halfAxes = Matrix3.ZERO;\r\n    result.center = Cartesian3.ZERO;\r\n    return result;\r\n  }\r\n\r\n  let i;\r\n  const length = positions.length;\r\n\r\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n  for (i = 1; i < length; i++) {\r\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n  }\r\n  const invLength = 1.0 / length;\r\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n  let exx = 0.0;\r\n  let exy = 0.0;\r\n  let exz = 0.0;\r\n  let eyy = 0.0;\r\n  let eyz = 0.0;\r\n  let ezz = 0.0;\r\n  let p;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n    exx += p.x * p.x;\r\n    exy += p.x * p.y;\r\n    exz += p.x * p.z;\r\n    eyy += p.y * p.y;\r\n    eyz += p.y * p.z;\r\n    ezz += p.z * p.z;\r\n  }\r\n\r\n  exx *= invLength;\r\n  exy *= invLength;\r\n  exz *= invLength;\r\n  eyy *= invLength;\r\n  eyz *= invLength;\r\n  ezz *= invLength;\r\n\r\n  const covarianceMatrix = scratchCovarianceResult;\r\n  covarianceMatrix[0] = exx;\r\n  covarianceMatrix[1] = exy;\r\n  covarianceMatrix[2] = exz;\r\n  covarianceMatrix[3] = exy;\r\n  covarianceMatrix[4] = eyy;\r\n  covarianceMatrix[5] = eyz;\r\n  covarianceMatrix[6] = exz;\r\n  covarianceMatrix[7] = eyz;\r\n  covarianceMatrix[8] = ezz;\r\n\r\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\r\n    covarianceMatrix,\r\n    scratchEigenResult\r\n  );\r\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n  let u1 = -Number.MAX_VALUE;\r\n  let u2 = -Number.MAX_VALUE;\r\n  let u3 = -Number.MAX_VALUE;\r\n  let l1 = Number.MAX_VALUE;\r\n  let l2 = Number.MAX_VALUE;\r\n  let l3 = Number.MAX_VALUE;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = positions[i];\r\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n  }\r\n\r\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n  const center = Cartesian3.add(v1, v2, result.center);\r\n  Cartesian3.add(center, v3, center);\r\n\r\n  const scale = scratchCartesian3;\r\n  scale.x = u1 - l1;\r\n  scale.y = u2 - l2;\r\n  scale.z = u3 - l3;\r\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchOffset = new Cartesian3();\r\nconst scratchScale = new Cartesian3();\r\nfunction fromPlaneExtents(\r\n  planeOrigin,\r\n  planeXAxis,\r\n  planeYAxis,\r\n  planeZAxis,\r\n  minimumX,\r\n  maximumX,\r\n  minimumY,\r\n  maximumY,\r\n  minimumZ,\r\n  maximumZ,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(minimumX) ||\r\n    !defined(maximumX) ||\r\n    !defined(minimumY) ||\r\n    !defined(maximumY) ||\r\n    !defined(minimumZ) ||\r\n    !defined(maximumZ)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  const halfAxes = result.halfAxes;\r\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n  let centerOffset = scratchOffset;\r\n  centerOffset.x = (minimumX + maximumX) / 2.0;\r\n  centerOffset.y = (minimumY + maximumY) / 2.0;\r\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n  const scale = scratchScale;\r\n  scale.x = (maximumX - minimumX) / 2.0;\r\n  scale.y = (maximumY - minimumY) / 2.0;\r\n  scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n  const center = result.center;\r\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n  Cartesian3.add(planeOrigin, centerOffset, center);\r\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n  return result;\r\n}\r\n\r\nconst scratchRectangleCenterCartographic = new Cartographic();\r\nconst scratchRectangleCenter = new Cartesian3();\r\nconst scratchPerimeterCartographicNC = new Cartographic();\r\nconst scratchPerimeterCartographicNW = new Cartographic();\r\nconst scratchPerimeterCartographicCW = new Cartographic();\r\nconst scratchPerimeterCartographicSW = new Cartographic();\r\nconst scratchPerimeterCartographicSC = new Cartographic();\r\nconst scratchPerimeterCartesianNC = new Cartesian3();\r\nconst scratchPerimeterCartesianNW = new Cartesian3();\r\nconst scratchPerimeterCartesianCW = new Cartesian3();\r\nconst scratchPerimeterCartesianSW = new Cartesian3();\r\nconst scratchPerimeterCartesianSC = new Cartesian3();\r\nconst scratchPerimeterProjectedNC = new Cartesian2();\r\nconst scratchPerimeterProjectedNW = new Cartesian2();\r\nconst scratchPerimeterProjectedCW = new Cartesian2();\r\nconst scratchPerimeterProjectedSW = new Cartesian2();\r\nconst scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\nconst scratchPlaneOrigin = new Cartesian3();\r\nconst scratchPlaneNormal = new Cartesian3();\r\nconst scratchPlaneXAxis = new Cartesian3();\r\nconst scratchHorizonCartesian = new Cartesian3();\r\nconst scratchHorizonProjected = new Cartesian2();\r\nconst scratchMaxY = new Cartesian3();\r\nconst scratchMinY = new Cartesian3();\r\nconst scratchZ = new Cartesian3();\r\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n * There are no guarantees about the orientation of the bounding box.\r\n *\r\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n *\r\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n */\r\nOrientedBoundingBox.fromRectangle = function (\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required\");\r\n  }\r\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\r\n  }\r\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\r\n  }\r\n  if (\r\n    defined(ellipsoid) &&\r\n    !CesiumMath.equalsEpsilon(\r\n      ellipsoid.radii.x,\r\n      ellipsoid.radii.y,\r\n      CesiumMath.EPSILON15\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  minimumHeight = defaultValue(minimumHeight, 0.0);\r\n  maximumHeight = defaultValue(maximumHeight, 0.0);\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n  if (rectangle.width <= CesiumMath.PI) {\r\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n    const tangentPointCartographic = Rectangle.center(\r\n      rectangle,\r\n      scratchRectangleCenterCartographic\r\n    );\r\n    const tangentPoint = ellipsoid.cartographicToCartesian(\r\n      tangentPointCartographic,\r\n      scratchRectangleCenter\r\n    );\r\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n    plane = tangentPlane.plane;\r\n\r\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n    const lonCenter = tangentPointCartographic.longitude;\r\n    const latCenter =\r\n      rectangle.south < 0.0 && rectangle.north > 0.0\r\n        ? 0.0\r\n        : tangentPointCartographic.latitude;\r\n\r\n    // Compute XY extents using the rectangle at maximum height\r\n    const perimeterCartographicNC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNC\r\n    );\r\n    const perimeterCartographicNW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNW\r\n    );\r\n    const perimeterCartographicCW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      latCenter,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicCW\r\n    );\r\n    const perimeterCartographicSW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSW\r\n    );\r\n    const perimeterCartographicSC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSC\r\n    );\r\n\r\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNC,\r\n      scratchPerimeterCartesianNC\r\n    );\r\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicCW,\r\n      scratchPerimeterCartesianCW\r\n    );\r\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSC,\r\n      scratchPerimeterCartesianSC\r\n    );\r\n\r\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNC,\r\n      scratchPerimeterProjectedNC\r\n    );\r\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNW,\r\n      scratchPerimeterProjectedNW\r\n    );\r\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianCW,\r\n      scratchPerimeterProjectedCW\r\n    );\r\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSW,\r\n      scratchPerimeterProjectedSW\r\n    );\r\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSC,\r\n      scratchPerimeterProjectedSC\r\n    );\r\n\r\n    minX = Math.min(\r\n      perimeterProjectedNW.x,\r\n      perimeterProjectedCW.x,\r\n      perimeterProjectedSW.x\r\n    );\r\n    maxX = -minX; // symmetrical\r\n\r\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n\r\n    minZ = Math.min(\r\n      Plane.getPointDistance(plane, perimeterCartesianNW),\r\n      Plane.getPointDistance(plane, perimeterCartesianSW)\r\n    );\r\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n    return fromPlaneExtents(\r\n      tangentPlane.origin,\r\n      tangentPlane.xAxis,\r\n      tangentPlane.yAxis,\r\n      tangentPlane.zAxis,\r\n      minX,\r\n      maxX,\r\n      minY,\r\n      maxY,\r\n      minZ,\r\n      maxZ,\r\n      result\r\n    );\r\n  }\r\n\r\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n  const fullyAboveEquator = rectangle.south > 0.0;\r\n  const fullyBelowEquator = rectangle.north < 0.0;\r\n  const latitudeNearestToEquator = fullyAboveEquator\r\n    ? rectangle.south\r\n    : fullyBelowEquator\r\n    ? rectangle.north\r\n    : 0.0;\r\n  const centerLongitude = Rectangle.center(\r\n    rectangle,\r\n    scratchRectangleCenterCartographic\r\n  ).longitude;\r\n\r\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n  const planeOrigin = Cartesian3.fromRadians(\r\n    centerLongitude,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchPlaneOrigin\r\n  );\r\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n  const isPole =\r\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\r\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n  const planeNormal = !isPole\r\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\r\n    : Cartesian3.UNIT_X;\r\n  const planeYAxis = Cartesian3.UNIT_Z;\r\n  const planeXAxis = Cartesian3.cross(\r\n    planeNormal,\r\n    planeYAxis,\r\n    scratchPlaneXAxis\r\n  );\r\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n  const horizonCartesian = Cartesian3.fromRadians(\r\n    centerLongitude + CesiumMath.PI_OVER_TWO,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchHorizonCartesian\r\n  );\r\n  maxX = Cartesian3.dot(\r\n    Plane.projectPointOntoPlane(\r\n      plane,\r\n      horizonCartesian,\r\n      scratchHorizonProjected\r\n    ),\r\n    planeXAxis\r\n  );\r\n  minX = -maxX; // symmetrical\r\n\r\n  // Get the min and max Y, using the height that will give the largest extent\r\n  maxY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.north,\r\n    fullyBelowEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMaxY\r\n  ).z;\r\n  minY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.south,\r\n    fullyAboveEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMinY\r\n  ).z;\r\n\r\n  const farZ = Cartesian3.fromRadians(\r\n    rectangle.east,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchZ\r\n  );\r\n  minZ = Plane.getPointDistance(plane, farZ);\r\n  maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n  // min and max are local to the plane axes\r\n  return fromPlaneExtents(\r\n    planeOrigin,\r\n    planeXAxis,\r\n    planeYAxis,\r\n    planeNormal,\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    minZ,\r\n    maxZ,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds an affine transformation.\r\n *\r\n * @param {Matrix4} transformation The affine transformation.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n */\r\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"transformation\", transformation);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  result.center = Matrix4.getTranslation(transformation, result.center);\r\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\r\n  result.halfAxes = Matrix3.multiplyByScalar(\r\n    result.halfAxes,\r\n    0.5,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\n/**\r\n * Duplicates a OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nOrientedBoundingBox.clone = function (box, result) {\r\n  if (!defined(box)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new OrientedBoundingBox(box.center, box.halfAxes);\r\n  }\r\n\r\n  Cartesian3.clone(box.center, result.center);\r\n  Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.intersectPlane = function (box, plane) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(plane)) {\r\n    throw new DeveloperError(\"plane is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const center = box.center;\r\n  const normal = plane.normal;\r\n  const halfAxes = box.halfAxes;\r\n  const normalX = normal.x,\r\n    normalY = normal.y,\r\n    normalZ = normal.z;\r\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n  const radEffective =\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\r\n    );\r\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n  if (distanceToPlane <= -radEffective) {\r\n    // The entire box is on the negative side of the plane normal\r\n    return Intersect.OUTSIDE;\r\n  } else if (distanceToPlane >= radEffective) {\r\n    // The entire box is on the positive side of the plane normal\r\n    return Intersect.INSIDE;\r\n  }\r\n  return Intersect.INTERSECTING;\r\n};\r\n\r\nconst scratchCartesianU = new Cartesian3();\r\nconst scratchCartesianV = new Cartesian3();\r\nconst scratchCartesianW = new Cartesian3();\r\nconst scratchValidAxis2 = new Cartesian3();\r\nconst scratchValidAxis3 = new Cartesian3();\r\nconst scratchPPrime = new Cartesian3();\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {OrientedBoundingBox} box The box.\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\r\n  // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(cartesian)) {\r\n    throw new DeveloperError(\"cartesian is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n  const halfAxes = box.halfAxes;\r\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  const uHalf = Cartesian3.magnitude(u);\r\n  const vHalf = Cartesian3.magnitude(v);\r\n  const wHalf = Cartesian3.magnitude(w);\r\n\r\n  let uValid = true;\r\n  let vValid = true;\r\n  let wValid = true;\r\n\r\n  if (uHalf > 0) {\r\n    Cartesian3.divideByScalar(u, uHalf, u);\r\n  } else {\r\n    uValid = false;\r\n  }\r\n\r\n  if (vHalf > 0) {\r\n    Cartesian3.divideByScalar(v, vHalf, v);\r\n  } else {\r\n    vValid = false;\r\n  }\r\n\r\n  if (wHalf > 0) {\r\n    Cartesian3.divideByScalar(w, wHalf, w);\r\n  } else {\r\n    wValid = false;\r\n  }\r\n\r\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\r\n  let validAxis1;\r\n  let validAxis2;\r\n  let validAxis3;\r\n\r\n  if (numberOfDegenerateAxes === 1) {\r\n    let degenerateAxis = u;\r\n    validAxis1 = v;\r\n    validAxis2 = w;\r\n    if (!vValid) {\r\n      degenerateAxis = v;\r\n      validAxis1 = u;\r\n    } else if (!wValid) {\r\n      degenerateAxis = w;\r\n      validAxis2 = u;\r\n    }\r\n\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n\r\n    if (degenerateAxis === u) {\r\n      u = validAxis3;\r\n    } else if (degenerateAxis === v) {\r\n      v = validAxis3;\r\n    } else if (degenerateAxis === w) {\r\n      w = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 2) {\r\n    validAxis1 = u;\r\n    if (vValid) {\r\n      validAxis1 = v;\r\n    } else if (wValid) {\r\n      validAxis1 = w;\r\n    }\r\n\r\n    let crossVector = Cartesian3.UNIT_Y;\r\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\r\n      crossVector = Cartesian3.UNIT_X;\r\n    }\r\n\r\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\r\n    Cartesian3.normalize(validAxis2, validAxis2);\r\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\r\n    Cartesian3.normalize(validAxis3, validAxis3);\r\n\r\n    if (validAxis1 === u) {\r\n      v = validAxis2;\r\n      w = validAxis3;\r\n    } else if (validAxis1 === v) {\r\n      w = validAxis2;\r\n      u = validAxis3;\r\n    } else if (validAxis1 === w) {\r\n      u = validAxis2;\r\n      v = validAxis3;\r\n    }\r\n  } else if (numberOfDegenerateAxes === 3) {\r\n    u = Cartesian3.UNIT_X;\r\n    v = Cartesian3.UNIT_Y;\r\n    w = Cartesian3.UNIT_Z;\r\n  }\r\n\r\n  const pPrime = scratchPPrime;\r\n  pPrime.x = Cartesian3.dot(offset, u);\r\n  pPrime.y = Cartesian3.dot(offset, v);\r\n  pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n  let distanceSquared = 0.0;\r\n  let d;\r\n\r\n  if (pPrime.x < -uHalf) {\r\n    d = pPrime.x + uHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.x > uHalf) {\r\n    d = pPrime.x - uHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.y < -vHalf) {\r\n    d = pPrime.y + vHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.y > vHalf) {\r\n    d = pPrime.y - vHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.z < -wHalf) {\r\n    d = pPrime.z + wHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.z > wHalf) {\r\n    d = pPrime.z - wHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  return distanceSquared;\r\n};\r\n\r\nconst scratchCorner = new Cartesian3();\r\nconst scratchToCenter = new Cartesian3();\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.computePlaneDistances = function (\r\n  box,\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Interval();\r\n  }\r\n\r\n  let minDist = Number.POSITIVE_INFINITY;\r\n  let maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n  const center = box.center;\r\n  const halfAxes = box.halfAxes;\r\n\r\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  // project first corner\r\n  const corner = Cartesian3.add(u, v, scratchCorner);\r\n  Cartesian3.add(corner, w, corner);\r\n  Cartesian3.add(corner, center, corner);\r\n\r\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n  let mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project second corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project third corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fourth corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fifth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project sixth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project seventh corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project eighth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  result.start = minDist;\r\n  result.stop = maxDist;\r\n  return result;\r\n};\r\n\r\nconst scratchXAxis = new Cartesian3();\r\nconst scratchYAxis = new Cartesian3();\r\nconst scratchZAxis = new Cartesian3();\r\n\r\n/**\r\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box.\r\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\r\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\r\n */\r\nOrientedBoundingBox.computeCorners = function (box, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"box\", box);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = [\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n      new Cartesian3(),\r\n    ];\r\n  }\r\n\r\n  const center = box.center;\r\n  const halfAxes = box.halfAxes;\r\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\r\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\r\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\r\n\r\n  Cartesian3.clone(center, result[0]);\r\n  Cartesian3.subtract(result[0], xAxis, result[0]);\r\n  Cartesian3.subtract(result[0], yAxis, result[0]);\r\n  Cartesian3.subtract(result[0], zAxis, result[0]);\r\n\r\n  Cartesian3.clone(center, result[1]);\r\n  Cartesian3.subtract(result[1], xAxis, result[1]);\r\n  Cartesian3.subtract(result[1], yAxis, result[1]);\r\n  Cartesian3.add(result[1], zAxis, result[1]);\r\n\r\n  Cartesian3.clone(center, result[2]);\r\n  Cartesian3.subtract(result[2], xAxis, result[2]);\r\n  Cartesian3.add(result[2], yAxis, result[2]);\r\n  Cartesian3.subtract(result[2], zAxis, result[2]);\r\n\r\n  Cartesian3.clone(center, result[3]);\r\n  Cartesian3.subtract(result[3], xAxis, result[3]);\r\n  Cartesian3.add(result[3], yAxis, result[3]);\r\n  Cartesian3.add(result[3], zAxis, result[3]);\r\n\r\n  Cartesian3.clone(center, result[4]);\r\n  Cartesian3.add(result[4], xAxis, result[4]);\r\n  Cartesian3.subtract(result[4], yAxis, result[4]);\r\n  Cartesian3.subtract(result[4], zAxis, result[4]);\r\n\r\n  Cartesian3.clone(center, result[5]);\r\n  Cartesian3.add(result[5], xAxis, result[5]);\r\n  Cartesian3.subtract(result[5], yAxis, result[5]);\r\n  Cartesian3.add(result[5], zAxis, result[5]);\r\n\r\n  Cartesian3.clone(center, result[6]);\r\n  Cartesian3.add(result[6], xAxis, result[6]);\r\n  Cartesian3.add(result[6], yAxis, result[6]);\r\n  Cartesian3.subtract(result[6], zAxis, result[6]);\r\n\r\n  Cartesian3.clone(center, result[7]);\r\n  Cartesian3.add(result[7], xAxis, result[7]);\r\n  Cartesian3.add(result[7], yAxis, result[7]);\r\n  Cartesian3.add(result[7], zAxis, result[7]);\r\n\r\n  return result;\r\n};\r\n\r\nconst scratchRotationScale = new Matrix3();\r\n\r\n/**\r\n * Computes a transformation matrix from an oriented bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box.\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\r\n */\r\nOrientedBoundingBox.computeTransformation = function (box, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"box\", box);\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Matrix4();\r\n  }\r\n\r\n  const translation = box.center;\r\n  const rotationScale = Matrix3.multiplyByUniformScale(\r\n    box.halfAxes,\r\n    2.0,\r\n    scratchRotationScale\r\n  );\r\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\r\n};\r\n\r\nconst scratchBoundingSphere = new BoundingSphere();\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.isOccluded = function (box, occluder) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(occluder)) {\r\n    throw new DeveloperError(\"occluder is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\r\n    box,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return !occluder.isBoundingSphereVisible(sphere);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\r\n  return OrientedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\r\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n};\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.prototype.computePlaneDistances = function (\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  return OrientedBoundingBox.computePlaneDistances(\r\n    this,\r\n    position,\r\n    direction,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\r\n *\r\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\r\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\r\n */\r\nOrientedBoundingBox.prototype.computeCorners = function (result) {\r\n  return OrientedBoundingBox.computeCorners(this, result);\r\n};\r\n\r\n/**\r\n * Computes a transformation matrix from an oriented bounding box.\r\n *\r\n * @param {Matrix4} result The object onto which to store the result.\r\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\r\n */\r\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\r\n  return OrientedBoundingBox.computeTransformation(this, result);\r\n};\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\r\n  return OrientedBoundingBox.isOccluded(this, occluder);\r\n};\r\n\r\n/**\r\n * Compares the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Cartesian3.equals(left.center, right.center) &&\r\n      Matrix3.equals(left.halfAxes, right.halfAxes))\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates this OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.prototype.clone = function (result) {\r\n  return OrientedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.prototype.equals = function (right) {\r\n  return OrientedBoundingBox.equals(this, right);\r\n};\r\nexport default OrientedBoundingBox;\r\n"],"names":["Cartesian3","defaultValue","Matrix3","Check","defined","DeveloperError","Cartographic","Cartesian2","Plane","CesiumMath","Ellipsoid","Rectangle","EllipsoidTangentPlane","Matrix4","Intersect","Interval","BoundingSphere"],"mappings":"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"}