{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../Source/Core/GeographicTilingScheme.js","../../../Source/Core/ApproximateTerrainHeights.js","../../../Source/Core/GroundPolylineGeometry.js","../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport GeographicProjection from \"./GeographicProjection.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\r\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\r\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\r\n *\r\n * @alias GeographicTilingScheme\r\n * @constructor\r\n *\r\n * @param {Object} [options] Object with the following properties:\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\r\n * the WGS84 ellipsoid.\r\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\r\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\r\n * the tile tree.\r\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\r\n * the tile tree.\r\n */\r\nfunction GeographicTilingScheme(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\r\n  this._projection = new GeographicProjection(this._ellipsoid);\r\n  this._numberOfLevelZeroTilesX = defaultValue(\r\n    options.numberOfLevelZeroTilesX,\r\n    2\r\n  );\r\n  this._numberOfLevelZeroTilesY = defaultValue(\r\n    options.numberOfLevelZeroTilesY,\r\n    1\r\n  );\r\n}\r\n\r\nObject.defineProperties(GeographicTilingScheme.prototype, {\r\n  /**\r\n   * Gets the ellipsoid that is tiled by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {Ellipsoid}\r\n   */\r\n  ellipsoid: {\r\n    get: function () {\r\n      return this._ellipsoid;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the rectangle, in radians, covered by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {Rectangle}\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      return this._rectangle;\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Gets the map projection used by this tiling scheme.\r\n   * @memberof GeographicTilingScheme.prototype\r\n   * @type {MapProjection}\r\n   */\r\n  projection: {\r\n    get: function () {\r\n      return this._projection;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the X direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\r\n  return this._numberOfLevelZeroTilesX << level;\r\n};\r\n\r\n/**\r\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\r\n *\r\n * @param {Number} level The level-of-detail.\r\n * @returns {Number} The number of tiles in the Y direction at the given level.\r\n */\r\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\r\n  return this._numberOfLevelZeroTilesY << level;\r\n};\r\n\r\n/**\r\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\r\n * of this tiling scheme.\r\n *\r\n * @param {Rectangle} rectangle The rectangle to transform.\r\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\r\n *          is undefined.\r\n */\r\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\r\n  rectangle,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  //>>includeEnd('debug');\r\n\r\n  const west = CesiumMath.toDegrees(rectangle.west);\r\n  const south = CesiumMath.toDegrees(rectangle.south);\r\n  const east = CesiumMath.toDegrees(rectangle.east);\r\n  const north = CesiumMath.toDegrees(rectangle.north);\r\n\r\n  if (!defined(result)) {\r\n    return new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\r\n * of the tiling scheme.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\r\n  x,\r\n  y,\r\n  level,\r\n  result\r\n) {\r\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\r\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\r\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\r\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\r\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\r\n  return rectangleRadians;\r\n};\r\n\r\n/**\r\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\r\n *\r\n * @param {Number} x The integer x coordinate of the tile.\r\n * @param {Number} y The integer y coordinate of the tile.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\r\n  x,\r\n  y,\r\n  level,\r\n  result\r\n) {\r\n  const rectangle = this._rectangle;\r\n\r\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\r\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n  const xTileWidth = rectangle.width / xTiles;\r\n  const west = x * xTileWidth + rectangle.west;\r\n  const east = (x + 1) * xTileWidth + rectangle.west;\r\n\r\n  const yTileHeight = rectangle.height / yTiles;\r\n  const north = rectangle.north - y * yTileHeight;\r\n  const south = rectangle.north - (y + 1) * yTileHeight;\r\n\r\n  if (!defined(result)) {\r\n    result = new Rectangle(west, south, east, north);\r\n  }\r\n\r\n  result.west = west;\r\n  result.south = south;\r\n  result.east = east;\r\n  result.north = north;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Calculates the tile x, y coordinates of the tile containing\r\n * a given cartographic position.\r\n *\r\n * @param {Cartographic} position The position.\r\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\r\n *        should be created.\r\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\r\n *          if 'result' is undefined.\r\n */\r\nGeographicTilingScheme.prototype.positionToTileXY = function (\r\n  position,\r\n  level,\r\n  result\r\n) {\r\n  const rectangle = this._rectangle;\r\n  if (!Rectangle.contains(rectangle, position)) {\r\n    // outside the bounds of the tiling scheme\r\n    return undefined;\r\n  }\r\n\r\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\r\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n  const xTileWidth = rectangle.width / xTiles;\r\n  const yTileHeight = rectangle.height / yTiles;\r\n\r\n  let longitude = position.longitude;\r\n  if (rectangle.east < rectangle.west) {\r\n    longitude += CesiumMath.TWO_PI;\r\n  }\r\n\r\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\r\n  if (xTileCoordinate >= xTiles) {\r\n    xTileCoordinate = xTiles - 1;\r\n  }\r\n\r\n  let yTileCoordinate =\r\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\r\n  if (yTileCoordinate >= yTiles) {\r\n    yTileCoordinate = yTiles - 1;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\r\n  }\r\n\r\n  result.x = xTileCoordinate;\r\n  result.y = yTileCoordinate;\r\n  return result;\r\n};\r\nexport default GeographicTilingScheme;\r\n","import BoundingSphere from \"./BoundingSphere.js\";\r\nimport buildModuleUrl from \"./buildModuleUrl.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport Resource from \"./Resource.js\";\r\n\r\nconst scratchDiagonalCartesianNE = new Cartesian3();\r\nconst scratchDiagonalCartesianSW = new Cartesian3();\r\nconst scratchDiagonalCartographic = new Cartographic();\r\nconst scratchCenterCartesian = new Cartesian3();\r\nconst scratchSurfaceCartesian = new Cartesian3();\r\n\r\nconst scratchBoundingSphere = new BoundingSphere();\r\nconst tilingScheme = new GeographicTilingScheme();\r\nconst scratchCorners = [\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n  new Cartographic(),\r\n];\r\nconst scratchTileXY = new Cartesian2();\r\n\r\n/**\r\n * A collection of functions for approximating terrain height\r\n * @private\r\n */\r\nconst ApproximateTerrainHeights = {};\r\n\r\n/**\r\n * Initializes the minimum and maximum terrain heights\r\n * @return {Promise.<void>}\r\n */\r\nApproximateTerrainHeights.initialize = function () {\r\n  let initPromise = ApproximateTerrainHeights._initPromise;\r\n  if (defined(initPromise)) {\r\n    return initPromise;\r\n  }\r\n\r\n  initPromise = Resource.fetchJson(\r\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\")\r\n  ).then(function (json) {\r\n    ApproximateTerrainHeights._terrainHeights = json;\r\n  });\r\n  ApproximateTerrainHeights._initPromise = initPromise;\r\n\r\n  return initPromise;\r\n};\r\n\r\n/**\r\n * Computes the minimum and maximum terrain heights for a given rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\r\n */\r\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\r\n  rectangle,\r\n  ellipsoid\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n    throw new DeveloperError(\r\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const xyLevel = getTileXYLevel(rectangle);\r\n\r\n  // Get the terrain min/max for that tile\r\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n  if (defined(xyLevel)) {\r\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\r\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\r\n    if (defined(heights)) {\r\n      minTerrainHeight = heights[0];\r\n      maxTerrainHeight = heights[1];\r\n    }\r\n\r\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\r\n    ellipsoid.cartographicToCartesian(\r\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\r\n      scratchDiagonalCartesianNE\r\n    );\r\n    ellipsoid.cartographicToCartesian(\r\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\r\n      scratchDiagonalCartesianSW\r\n    );\r\n\r\n    Cartesian3.midpoint(\r\n      scratchDiagonalCartesianSW,\r\n      scratchDiagonalCartesianNE,\r\n      scratchCenterCartesian\r\n    );\r\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(\r\n      scratchCenterCartesian,\r\n      scratchSurfaceCartesian\r\n    );\r\n    if (defined(surfacePosition)) {\r\n      const distance = Cartesian3.distance(\r\n        scratchCenterCartesian,\r\n        surfacePosition\r\n      );\r\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\r\n    } else {\r\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n    }\r\n  }\r\n\r\n  minTerrainHeight = Math.max(\r\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n    minTerrainHeight\r\n  );\r\n\r\n  return {\r\n    minimumTerrainHeight: minTerrainHeight,\r\n    maximumTerrainHeight: maxTerrainHeight,\r\n  };\r\n};\r\n\r\n/**\r\n * Computes the bounding sphere based on the tile heights in the rectangle\r\n * @param {Rectangle} rectangle The bounding rectangle\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n * @return {BoundingSphere} The result bounding sphere\r\n */\r\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"rectangle\", rectangle);\r\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n    throw new DeveloperError(\r\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  const xyLevel = getTileXYLevel(rectangle);\r\n\r\n  // Get the terrain max for that tile\r\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n  if (defined(xyLevel)) {\r\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\r\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\r\n    if (defined(heights)) {\r\n      maxTerrainHeight = heights[1];\r\n    }\r\n  }\r\n\r\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\r\n  BoundingSphere.fromRectangle3D(\r\n    rectangle,\r\n    ellipsoid,\r\n    maxTerrainHeight,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\r\n};\r\n\r\nfunction getTileXYLevel(rectangle) {\r\n  Cartographic.fromRadians(\r\n    rectangle.east,\r\n    rectangle.north,\r\n    0.0,\r\n    scratchCorners[0]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.west,\r\n    rectangle.north,\r\n    0.0,\r\n    scratchCorners[1]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.east,\r\n    rectangle.south,\r\n    0.0,\r\n    scratchCorners[2]\r\n  );\r\n  Cartographic.fromRadians(\r\n    rectangle.west,\r\n    rectangle.south,\r\n    0.0,\r\n    scratchCorners[3]\r\n  );\r\n\r\n  // Determine which tile the bounding rectangle is in\r\n  let lastLevelX = 0,\r\n    lastLevelY = 0;\r\n  let currentX = 0,\r\n    currentY = 0;\r\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\r\n  let i;\r\n  for (i = 0; i <= maxLevel; ++i) {\r\n    let failed = false;\r\n    for (let j = 0; j < 4; ++j) {\r\n      const corner = scratchCorners[j];\r\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\r\n      if (j === 0) {\r\n        currentX = scratchTileXY.x;\r\n        currentY = scratchTileXY.y;\r\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\r\n        failed = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (failed) {\r\n      break;\r\n    }\r\n\r\n    lastLevelX = currentX;\r\n    lastLevelY = currentY;\r\n  }\r\n\r\n  if (i === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return {\r\n    x: lastLevelX,\r\n    y: lastLevelY,\r\n    level: i > maxLevel ? maxLevel : i - 1,\r\n  };\r\n}\r\n\r\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\r\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\r\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\r\nApproximateTerrainHeights._terrainHeights = undefined;\r\nApproximateTerrainHeights._initPromise = undefined;\r\n\r\nObject.defineProperties(ApproximateTerrainHeights, {\r\n  /**\r\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\r\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\r\n   * @type {Boolean}\r\n   * @readonly\r\n   * @memberof ApproximateTerrainHeights\r\n   */\r\n  initialized: {\r\n    get: function () {\r\n      return defined(ApproximateTerrainHeights._terrainHeights);\r\n    },\r\n  },\r\n});\r\nexport default ApproximateTerrainHeights;\r\n","import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\r\nimport ArcType from \"./ArcType.js\";\r\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\r\nimport BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport ComponentDatatype from \"./ComponentDatatype.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\r\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\r\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\r\nimport GeographicProjection from \"./GeographicProjection.js\";\r\nimport Geometry from \"./Geometry.js\";\r\nimport GeometryAttribute from \"./GeometryAttribute.js\";\r\nimport IntersectionTests from \"./IntersectionTests.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Quaternion from \"./Quaternion.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\r\n\r\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\r\nconst PROJECTION_COUNT = PROJECTIONS.length;\r\n\r\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\r\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\n// Initial heights for constructing the wall.\r\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\r\n// prevent precision problems with planes in the shader.\r\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n// which is a highly conservative bound, usually puts the plane origin several thousands\r\n// of meters away from the actual terrain, causing floating point problems when checking\r\n// fragments on terrain against the plane.\r\n// Ellipsoid height is generally much closer.\r\n// The initial max height is arbitrary.\r\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\r\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\r\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\r\n\r\n/**\r\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\r\n *\r\n * @alias GroundPolylineGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Options with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\r\n * @param {Number} [options.width=1.0] The screen space width in pixels.\r\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\r\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n *\r\n * @exception {DeveloperError} At least two positions are required.\r\n *\r\n * @see GroundPolylinePrimitive\r\n *\r\n * @example\r\n * const positions = Cesium.Cartesian3.fromDegreesArray([\r\n *   -112.1340164450331, 36.05494287836128,\r\n *   -112.08821010582645, 36.097804071380715,\r\n *   -112.13296079730024, 36.168769146801104\r\n * ]);\r\n *\r\n * const geometry = new Cesium.GroundPolylineGeometry({\r\n *   positions : positions\r\n * });\r\n */\r\nfunction GroundPolylineGeometry(options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n  const positions = options.positions;\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(positions) || positions.length < 2) {\r\n    throw new DeveloperError(\"At least two positions are required.\");\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  /**\r\n   * The screen space width in pixels.\r\n   * @type {Number}\r\n   */\r\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\r\n\r\n  this._positions = positions;\r\n\r\n  /**\r\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\r\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\r\n   * @type {Boolean}\r\n   * @default 9999.0\r\n   */\r\n  this.granularity = defaultValue(options.granularity, 9999.0);\r\n\r\n  /**\r\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n   * If the geometry has two positions this parameter will be ignored.\r\n   * @type {Boolean}\r\n   * @default false\r\n   */\r\n  this.loop = defaultValue(options.loop, false);\r\n\r\n  /**\r\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n   * @type {ArcType}\r\n   * @default ArcType.GEODESIC\r\n   */\r\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  this._ellipsoid = Ellipsoid.WGS84;\r\n\r\n  // MapProjections can't be packed, so store the index to a known MapProjection.\r\n  this._projectionIndex = 0;\r\n  this._workerName = \"createGroundPolylineGeometry\";\r\n\r\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\r\n  this._scene3DOnly = false;\r\n}\r\n\r\nObject.defineProperties(GroundPolylineGeometry.prototype, {\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @memberof GroundPolylineGeometry.prototype\r\n   * @type {Number}\r\n   * @readonly\r\n   * @private\r\n   */\r\n  packedLength: {\r\n    get: function () {\r\n      return (\r\n        1.0 +\r\n        this._positions.length * 3 +\r\n        1.0 +\r\n        1.0 +\r\n        1.0 +\r\n        Ellipsoid.packedLength +\r\n        1.0 +\r\n        1.0\r\n      );\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * Set the GroundPolylineGeometry's projection and ellipsoid.\r\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\r\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\r\n * @private\r\n */\r\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\r\n  groundPolylineGeometry,\r\n  mapProjection\r\n) {\r\n  let projectionIndex = 0;\r\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\r\n    if (mapProjection instanceof PROJECTIONS[i]) {\r\n      projectionIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  groundPolylineGeometry._projectionIndex = projectionIndex;\r\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\r\n};\r\n\r\nconst cart3Scratch1 = new Cartesian3();\r\nconst cart3Scratch2 = new Cartesian3();\r\nconst cart3Scratch3 = new Cartesian3();\r\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\r\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\r\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\r\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\r\n\r\n  const up = direction(startTop, startBottom, cart3Scratch2);\r\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\r\n\r\n  Cartesian3.cross(forward, up, result);\r\n  return Cartesian3.normalize(result, result);\r\n}\r\n\r\nconst interpolatedCartographicScratch = new Cartographic();\r\nconst interpolatedBottomScratch = new Cartesian3();\r\nconst interpolatedTopScratch = new Cartesian3();\r\nconst interpolatedNormalScratch = new Cartesian3();\r\nfunction interpolateSegment(\r\n  start,\r\n  end,\r\n  minHeight,\r\n  maxHeight,\r\n  granularity,\r\n  arcType,\r\n  ellipsoid,\r\n  normalsArray,\r\n  bottomPositionsArray,\r\n  topPositionsArray,\r\n  cartographicsArray\r\n) {\r\n  if (granularity === 0.0) {\r\n    return;\r\n  }\r\n\r\n  let ellipsoidLine;\r\n  if (arcType === ArcType.GEODESIC) {\r\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\r\n  } else if (arcType === ArcType.RHUMB) {\r\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\r\n  }\r\n\r\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\r\n  if (surfaceDistance < granularity) {\r\n    return;\r\n  }\r\n\r\n  // Compute rightwards normal applicable at all interpolated points\r\n  const interpolatedNormal = computeRightNormal(\r\n    start,\r\n    end,\r\n    maxHeight,\r\n    ellipsoid,\r\n    interpolatedNormalScratch\r\n  );\r\n\r\n  const segments = Math.ceil(surfaceDistance / granularity);\r\n  const interpointDistance = surfaceDistance / segments;\r\n  let distanceFromStart = interpointDistance;\r\n  const pointsToAdd = segments - 1;\r\n  let packIndex = normalsArray.length;\r\n  for (let i = 0; i < pointsToAdd; i++) {\r\n    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\r\n      distanceFromStart,\r\n      interpolatedCartographicScratch\r\n    );\r\n    const interpolatedBottom = getPosition(\r\n      ellipsoid,\r\n      interpolatedCartographic,\r\n      minHeight,\r\n      interpolatedBottomScratch\r\n    );\r\n    const interpolatedTop = getPosition(\r\n      ellipsoid,\r\n      interpolatedCartographic,\r\n      maxHeight,\r\n      interpolatedTopScratch\r\n    );\r\n\r\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\r\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\r\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\r\n    cartographicsArray.push(interpolatedCartographic.latitude);\r\n    cartographicsArray.push(interpolatedCartographic.longitude);\r\n\r\n    packIndex += 3;\r\n    distanceFromStart += interpointDistance;\r\n  }\r\n}\r\n\r\nconst heightlessCartographicScratch = new Cartographic();\r\nfunction getPosition(ellipsoid, cartographic, height, result) {\r\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\r\n  heightlessCartographicScratch.height = height;\r\n  return Cartographic.toCartesian(\r\n    heightlessCartographicScratch,\r\n    ellipsoid,\r\n    result\r\n  );\r\n}\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  let index = defaultValue(startingIndex, 0);\r\n\r\n  const positions = value._positions;\r\n  const positionsLength = positions.length;\r\n\r\n  array[index++] = positionsLength;\r\n\r\n  for (let i = 0; i < positionsLength; ++i) {\r\n    const cartesian = positions[i];\r\n    Cartesian3.pack(cartesian, array, index);\r\n    index += 3;\r\n  }\r\n\r\n  array[index++] = value.granularity;\r\n  array[index++] = value.loop ? 1.0 : 0.0;\r\n  array[index++] = value.arcType;\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, index);\r\n  index += Ellipsoid.packedLength;\r\n\r\n  array[index++] = value._projectionIndex;\r\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  let index = defaultValue(startingIndex, 0);\r\n  const positionsLength = array[index++];\r\n  const positions = new Array(positionsLength);\r\n\r\n  for (let i = 0; i < positionsLength; i++) {\r\n    positions[i] = Cartesian3.unpack(array, index);\r\n    index += 3;\r\n  }\r\n\r\n  const granularity = array[index++];\r\n  const loop = array[index++] === 1.0;\r\n  const arcType = array[index++];\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, index);\r\n  index += Ellipsoid.packedLength;\r\n\r\n  const projectionIndex = array[index++];\r\n  const scene3DOnly = array[index++] === 1.0;\r\n\r\n  if (!defined(result)) {\r\n    result = new GroundPolylineGeometry({\r\n      positions: positions,\r\n    });\r\n  }\r\n\r\n  result._positions = positions;\r\n  result.granularity = granularity;\r\n  result.loop = loop;\r\n  result.arcType = arcType;\r\n  result._ellipsoid = ellipsoid;\r\n  result._projectionIndex = projectionIndex;\r\n  result._scene3DOnly = scene3DOnly;\r\n\r\n  return result;\r\n};\r\n\r\nfunction direction(target, origin, result) {\r\n  Cartesian3.subtract(target, origin, result);\r\n  Cartesian3.normalize(result, result);\r\n  return result;\r\n}\r\n\r\nfunction tangentDirection(target, origin, up, result) {\r\n  result = direction(target, origin, result);\r\n\r\n  // orthogonalize\r\n  result = Cartesian3.cross(result, up, result);\r\n  result = Cartesian3.normalize(result, result);\r\n  result = Cartesian3.cross(up, result, result);\r\n  return result;\r\n}\r\n\r\nconst toPreviousScratch = new Cartesian3();\r\nconst toNextScratch = new Cartesian3();\r\nconst forwardScratch = new Cartesian3();\r\nconst vertexUpScratch = new Cartesian3();\r\nconst cosine90 = 0.0;\r\nconst cosine180 = -1.0;\r\nfunction computeVertexMiterNormal(\r\n  previousBottom,\r\n  vertexBottom,\r\n  vertexTop,\r\n  nextBottom,\r\n  result\r\n) {\r\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\r\n\r\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\r\n  const toPrevious = tangentDirection(\r\n    previousBottom,\r\n    vertexBottom,\r\n    up,\r\n    toPreviousScratch\r\n  );\r\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\r\n\r\n  // Check if tangents are almost opposite - if so, no need to miter.\r\n  if (\r\n    CesiumMath.equalsEpsilon(\r\n      Cartesian3.dot(toPrevious, toNext),\r\n      cosine180,\r\n      CesiumMath.EPSILON5\r\n    )\r\n  ) {\r\n    result = Cartesian3.cross(up, toPrevious, result);\r\n    result = Cartesian3.normalize(result, result);\r\n    return result;\r\n  }\r\n\r\n  // Average directions to previous and to next in the plane of Up\r\n  result = Cartesian3.add(toNext, toPrevious, result);\r\n  result = Cartesian3.normalize(result, result);\r\n\r\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\r\n  const forward = Cartesian3.cross(up, result, forwardScratch);\r\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\r\n    result = Cartesian3.negate(result, result);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\nconst previousBottomScratch = new Cartesian3();\r\nconst vertexBottomScratch = new Cartesian3();\r\nconst vertexTopScratch = new Cartesian3();\r\nconst nextBottomScratch = new Cartesian3();\r\nconst vertexNormalScratch = new Cartesian3();\r\nconst intersectionScratch = new Cartesian3();\r\nconst cartographicScratch0 = new Cartographic();\r\nconst cartographicScratch1 = new Cartographic();\r\nconst cartographicIntersectionScratch = new Cartographic();\r\n/**\r\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\r\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\r\n * Should not be called independent of {@link GroundPolylinePrimitive}.\r\n *\r\n * @param {GroundPolylineGeometry} groundPolylineGeometry\r\n * @private\r\n */\r\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\r\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\r\n  let loop = groundPolylineGeometry.loop;\r\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\r\n  const granularity = groundPolylineGeometry.granularity;\r\n  const arcType = groundPolylineGeometry.arcType;\r\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\r\n    ellipsoid\r\n  );\r\n\r\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\r\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\r\n\r\n  let index;\r\n  let i;\r\n\r\n  const positions = groundPolylineGeometry._positions;\r\n  const positionsLength = positions.length;\r\n\r\n  if (positionsLength === 2) {\r\n    loop = false;\r\n  }\r\n\r\n  // Split positions across the IDL and the Prime Meridian as well.\r\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\r\n  // may get split by the plane of IDL + Prime Meridian.\r\n  let p0;\r\n  let p1;\r\n  let c0;\r\n  let c1;\r\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n  let intersection;\r\n  let intersectionCartographic;\r\n  let intersectionLongitude;\r\n  const splitPositions = [positions[0]];\r\n  for (i = 0; i < positionsLength - 1; i++) {\r\n    p0 = positions[i];\r\n    p1 = positions[i + 1];\r\n    intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p1,\r\n      XZ_PLANE,\r\n      intersectionScratch\r\n    );\r\n    if (\r\n      defined(intersection) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n    ) {\r\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n        splitPositions.push(Cartesian3.clone(intersection));\r\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\r\n          intersection,\r\n          cartographicScratch0\r\n        ).longitude;\r\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n        rhumbLine.setEndPoints(c0, c1);\r\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\r\n          intersectionLongitude,\r\n          cartographicIntersectionScratch\r\n        );\r\n        intersection = ellipsoid.cartographicToCartesian(\r\n          intersectionCartographic,\r\n          intersectionScratch\r\n        );\r\n        if (\r\n          defined(intersection) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n        ) {\r\n          splitPositions.push(Cartesian3.clone(intersection));\r\n        }\r\n      }\r\n    }\r\n    splitPositions.push(p1);\r\n  }\r\n\r\n  if (loop) {\r\n    p0 = positions[positionsLength - 1];\r\n    p1 = positions[0];\r\n    intersection = IntersectionTests.lineSegmentPlane(\r\n      p0,\r\n      p1,\r\n      XZ_PLANE,\r\n      intersectionScratch\r\n    );\r\n    if (\r\n      defined(intersection) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n    ) {\r\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n        splitPositions.push(Cartesian3.clone(intersection));\r\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\r\n          intersection,\r\n          cartographicScratch0\r\n        ).longitude;\r\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n        rhumbLine.setEndPoints(c0, c1);\r\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\r\n          intersectionLongitude,\r\n          cartographicIntersectionScratch\r\n        );\r\n        intersection = ellipsoid.cartographicToCartesian(\r\n          intersectionCartographic,\r\n          intersectionScratch\r\n        );\r\n        if (\r\n          defined(intersection) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\r\n        ) {\r\n          splitPositions.push(Cartesian3.clone(intersection));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  let cartographicsLength = splitPositions.length;\r\n\r\n  let cartographics = new Array(cartographicsLength);\r\n  for (i = 0; i < cartographicsLength; i++) {\r\n    const cartographic = Cartographic.fromCartesian(\r\n      splitPositions[i],\r\n      ellipsoid\r\n    );\r\n    cartographic.height = 0.0;\r\n    cartographics[i] = cartographic;\r\n  }\r\n\r\n  cartographics = arrayRemoveDuplicates(\r\n    cartographics,\r\n    Cartographic.equalsEpsilon\r\n  );\r\n  cartographicsLength = cartographics.length;\r\n\r\n  if (cartographicsLength < 2) {\r\n    return undefined;\r\n  }\r\n\r\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\r\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\r\n  // of information about the wall. Also, this simplifies interpolation.\r\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\r\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\r\n  const cartographicsArray = [];\r\n  const normalsArray = [];\r\n  const bottomPositionsArray = [];\r\n  const topPositionsArray = [];\r\n\r\n  let previousBottom = previousBottomScratch;\r\n  let vertexBottom = vertexBottomScratch;\r\n  let vertexTop = vertexTopScratch;\r\n  let nextBottom = nextBottomScratch;\r\n  let vertexNormal = vertexNormalScratch;\r\n\r\n  // First point - either loop or attach a \"perpendicular\" normal\r\n  const startCartographic = cartographics[0];\r\n  const nextCartographic = cartographics[1];\r\n\r\n  const prestartCartographic = cartographics[cartographicsLength - 1];\r\n  previousBottom = getPosition(\r\n    ellipsoid,\r\n    prestartCartographic,\r\n    minHeight,\r\n    previousBottom\r\n  );\r\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\r\n  vertexBottom = getPosition(\r\n    ellipsoid,\r\n    startCartographic,\r\n    minHeight,\r\n    vertexBottom\r\n  );\r\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\r\n\r\n  if (loop) {\r\n    vertexNormal = computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n  } else {\r\n    vertexNormal = computeRightNormal(\r\n      startCartographic,\r\n      nextCartographic,\r\n      maxHeight,\r\n      ellipsoid,\r\n      vertexNormal\r\n    );\r\n  }\r\n\r\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\r\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\r\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\r\n  cartographicsArray.push(startCartographic.latitude);\r\n  cartographicsArray.push(startCartographic.longitude);\r\n\r\n  interpolateSegment(\r\n    startCartographic,\r\n    nextCartographic,\r\n    minHeight,\r\n    maxHeight,\r\n    granularity,\r\n    arcType,\r\n    ellipsoid,\r\n    normalsArray,\r\n    bottomPositionsArray,\r\n    topPositionsArray,\r\n    cartographicsArray\r\n  );\r\n\r\n  // All inbetween points\r\n  for (i = 1; i < cartographicsLength - 1; ++i) {\r\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\r\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\r\n    const vertexCartographic = cartographics[i];\r\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\r\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\r\n\r\n    computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n\r\n    index = normalsArray.length;\r\n    Cartesian3.pack(vertexNormal, normalsArray, index);\r\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n    cartographicsArray.push(vertexCartographic.latitude);\r\n    cartographicsArray.push(vertexCartographic.longitude);\r\n\r\n    interpolateSegment(\r\n      cartographics[i],\r\n      cartographics[i + 1],\r\n      minHeight,\r\n      maxHeight,\r\n      granularity,\r\n      arcType,\r\n      ellipsoid,\r\n      normalsArray,\r\n      bottomPositionsArray,\r\n      topPositionsArray,\r\n      cartographicsArray\r\n    );\r\n  }\r\n\r\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\r\n  const endCartographic = cartographics[cartographicsLength - 1];\r\n  const preEndCartographic = cartographics[cartographicsLength - 2];\r\n\r\n  vertexBottom = getPosition(\r\n    ellipsoid,\r\n    endCartographic,\r\n    minHeight,\r\n    vertexBottom\r\n  );\r\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\r\n\r\n  if (loop) {\r\n    const postEndCartographic = cartographics[0];\r\n    previousBottom = getPosition(\r\n      ellipsoid,\r\n      preEndCartographic,\r\n      minHeight,\r\n      previousBottom\r\n    );\r\n    nextBottom = getPosition(\r\n      ellipsoid,\r\n      postEndCartographic,\r\n      minHeight,\r\n      nextBottom\r\n    );\r\n\r\n    vertexNormal = computeVertexMiterNormal(\r\n      previousBottom,\r\n      vertexBottom,\r\n      vertexTop,\r\n      nextBottom,\r\n      vertexNormal\r\n    );\r\n  } else {\r\n    vertexNormal = computeRightNormal(\r\n      preEndCartographic,\r\n      endCartographic,\r\n      maxHeight,\r\n      ellipsoid,\r\n      vertexNormal\r\n    );\r\n  }\r\n\r\n  index = normalsArray.length;\r\n  Cartesian3.pack(vertexNormal, normalsArray, index);\r\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n  cartographicsArray.push(endCartographic.latitude);\r\n  cartographicsArray.push(endCartographic.longitude);\r\n\r\n  if (loop) {\r\n    interpolateSegment(\r\n      endCartographic,\r\n      startCartographic,\r\n      minHeight,\r\n      maxHeight,\r\n      granularity,\r\n      arcType,\r\n      ellipsoid,\r\n      normalsArray,\r\n      bottomPositionsArray,\r\n      topPositionsArray,\r\n      cartographicsArray\r\n    );\r\n    index = normalsArray.length;\r\n    for (i = 0; i < 3; ++i) {\r\n      normalsArray[index + i] = normalsArray[i];\r\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\r\n      topPositionsArray[index + i] = topPositionsArray[i];\r\n    }\r\n    cartographicsArray.push(startCartographic.latitude);\r\n    cartographicsArray.push(startCartographic.longitude);\r\n  }\r\n\r\n  return generateGeometryAttributes(\r\n    loop,\r\n    projection,\r\n    bottomPositionsArray,\r\n    topPositionsArray,\r\n    normalsArray,\r\n    cartographicsArray,\r\n    compute2dAttributes\r\n  );\r\n};\r\n\r\n// If the end normal angle is too steep compared to the direction of the line segment,\r\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\r\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\r\nconst lineDirectionScratch = new Cartesian3();\r\nconst matrix3Scratch = new Matrix3();\r\nconst quaternionScratch = new Quaternion();\r\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\r\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\r\n\r\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\r\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\r\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\r\n    const angle =\r\n      dot < MITER_BREAK_LARGE\r\n        ? CesiumMath.PI_OVER_TWO\r\n        : -CesiumMath.PI_OVER_TWO;\r\n    const quaternion = Quaternion.fromAxisAngle(\r\n      vertexUp,\r\n      angle,\r\n      quaternionScratch\r\n    );\r\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\r\n    Matrix3.multiplyByVector(\r\n      rotationMatrix,\r\n      endGeometryNormal,\r\n      endGeometryNormal\r\n    );\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst endPosCartographicScratch = new Cartographic();\r\nconst normalStartpointScratch = new Cartesian3();\r\nconst normalEndpointScratch = new Cartesian3();\r\nfunction projectNormal(\r\n  projection,\r\n  cartographic,\r\n  normal,\r\n  projectedPosition,\r\n  result\r\n) {\r\n  const position = Cartographic.toCartesian(\r\n    cartographic,\r\n    projection._ellipsoid,\r\n    normalStartpointScratch\r\n  );\r\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\r\n  let flipNormal = false;\r\n\r\n  const ellipsoid = projection._ellipsoid;\r\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\r\n    normalEndpoint,\r\n    endPosCartographicScratch\r\n  );\r\n  // If normal crosses the IDL, go the other way and flip the result.\r\n  // In practice this almost never happens because the cartographic start\r\n  // and end points of each segment are \"nudged\" to be on the same side\r\n  // of the IDL and slightly away from the IDL.\r\n  if (\r\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\r\n    CesiumMath.PI_OVER_TWO\r\n  ) {\r\n    flipNormal = true;\r\n    normalEndpoint = Cartesian3.subtract(\r\n      position,\r\n      normal,\r\n      normalEndpointScratch\r\n    );\r\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\r\n      normalEndpoint,\r\n      endPosCartographicScratch\r\n    );\r\n  }\r\n\r\n  normalEndpointCartographic.height = 0.0;\r\n  const normalEndpointProjected = projection.project(\r\n    normalEndpointCartographic,\r\n    result\r\n  );\r\n  result = Cartesian3.subtract(\r\n    normalEndpointProjected,\r\n    projectedPosition,\r\n    result\r\n  );\r\n  result.z = 0.0;\r\n  result = Cartesian3.normalize(result, result);\r\n  if (flipNormal) {\r\n    Cartesian3.negate(result, result);\r\n  }\r\n  return result;\r\n}\r\n\r\nconst adjustHeightNormalScratch = new Cartesian3();\r\nconst adjustHeightOffsetScratch = new Cartesian3();\r\nfunction adjustHeights(\r\n  bottom,\r\n  top,\r\n  minHeight,\r\n  maxHeight,\r\n  adjustHeightBottom,\r\n  adjustHeightTop\r\n) {\r\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\r\n  const adjustHeightNormal = Cartesian3.subtract(\r\n    top,\r\n    bottom,\r\n    adjustHeightNormalScratch\r\n  );\r\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\r\n\r\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\r\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\r\n    adjustHeightNormal,\r\n    distanceForBottom,\r\n    adjustHeightOffsetScratch\r\n  );\r\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\r\n\r\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\r\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\r\n    adjustHeightNormal,\r\n    distanceForTop,\r\n    adjustHeightOffsetScratch\r\n  );\r\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\r\n}\r\n\r\nconst nudgeDirectionScratch = new Cartesian3();\r\nfunction nudgeXZ(start, end) {\r\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\r\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\r\n  let offset = nudgeDirectionScratch;\r\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\r\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n    offset = direction(end, start, offset);\r\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n    Cartesian3.add(start, offset, start);\r\n  } else if (\r\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\r\n  ) {\r\n    offset = direction(start, end, offset);\r\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n    Cartesian3.add(end, offset, end);\r\n  }\r\n}\r\n\r\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\r\n// Nudge amounts are tiny, basically just an IDL flip.\r\n// Only used for 2D/CV.\r\nfunction nudgeCartographic(start, end) {\r\n  const absStartLon = Math.abs(start.longitude);\r\n  const absEndLon = Math.abs(end.longitude);\r\n  if (\r\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\r\n  ) {\r\n    const endSign = CesiumMath.sign(end.longitude);\r\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\r\n    return 1;\r\n  } else if (\r\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\r\n  ) {\r\n    const startSign = CesiumMath.sign(start.longitude);\r\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\r\n    return 2;\r\n  }\r\n  return 0;\r\n}\r\n\r\nconst startCartographicScratch = new Cartographic();\r\nconst endCartographicScratch = new Cartographic();\r\n\r\nconst segmentStartTopScratch = new Cartesian3();\r\nconst segmentEndTopScratch = new Cartesian3();\r\nconst segmentStartBottomScratch = new Cartesian3();\r\nconst segmentEndBottomScratch = new Cartesian3();\r\nconst segmentStartNormalScratch = new Cartesian3();\r\nconst segmentEndNormalScratch = new Cartesian3();\r\n\r\nconst getHeightCartographics = [\r\n  startCartographicScratch,\r\n  endCartographicScratch,\r\n];\r\nconst getHeightRectangleScratch = new Rectangle();\r\n\r\nconst adjustHeightStartTopScratch = new Cartesian3();\r\nconst adjustHeightEndTopScratch = new Cartesian3();\r\nconst adjustHeightStartBottomScratch = new Cartesian3();\r\nconst adjustHeightEndBottomScratch = new Cartesian3();\r\n\r\nconst segmentStart2DScratch = new Cartesian3();\r\nconst segmentEnd2DScratch = new Cartesian3();\r\nconst segmentStartNormal2DScratch = new Cartesian3();\r\nconst segmentEndNormal2DScratch = new Cartesian3();\r\n\r\nconst offsetScratch = new Cartesian3();\r\nconst startUpScratch = new Cartesian3();\r\nconst endUpScratch = new Cartesian3();\r\nconst rightScratch = new Cartesian3();\r\nconst startPlaneNormalScratch = new Cartesian3();\r\nconst endPlaneNormalScratch = new Cartesian3();\r\nconst encodeScratch = new EncodedCartesian3();\r\n\r\nconst encodeScratch2D = new EncodedCartesian3();\r\nconst forwardOffset2DScratch = new Cartesian3();\r\nconst right2DScratch = new Cartesian3();\r\n\r\nconst normalNudgeScratch = new Cartesian3();\r\n\r\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\r\n\r\n// Winding order is reversed so each segment's volume is inside-out\r\nconst REFERENCE_INDICES = [\r\n  0,\r\n  2,\r\n  1,\r\n  0,\r\n  3,\r\n  2, // right\r\n  0,\r\n  7,\r\n  3,\r\n  0,\r\n  4,\r\n  7, // start\r\n  0,\r\n  5,\r\n  4,\r\n  0,\r\n  1,\r\n  5, // bottom\r\n  5,\r\n  7,\r\n  4,\r\n  5,\r\n  6,\r\n  7, // left\r\n  5,\r\n  2,\r\n  6,\r\n  5,\r\n  1,\r\n  2, // end\r\n  3,\r\n  6,\r\n  2,\r\n  3,\r\n  7,\r\n  6, // top\r\n];\r\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\n// Decompose the \"wall\" into a series of shadow volumes.\r\n// Each shadow volume's vertices encode a description of the line it contains,\r\n// including mitering planes at the end points, a plane along the line itself,\r\n// and attributes for computing length-wise texture coordinates.\r\nfunction generateGeometryAttributes(\r\n  loop,\r\n  projection,\r\n  bottomPositionsArray,\r\n  topPositionsArray,\r\n  normalsArray,\r\n  cartographicsArray,\r\n  compute2dAttributes\r\n) {\r\n  let i;\r\n  let index;\r\n  const ellipsoid = projection._ellipsoid;\r\n\r\n  // Each segment will have 8 vertices\r\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\r\n  const vertexCount = segmentCount * 8;\r\n  const arraySizeVec4 = vertexCount * 4;\r\n  const indexCount = segmentCount * 36;\r\n\r\n  const indices =\r\n    vertexCount > 65535\r\n      ? new Uint32Array(indexCount)\r\n      : new Uint16Array(indexCount);\r\n  const positionsArray = new Float64Array(vertexCount * 3);\r\n\r\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\r\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\r\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\r\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\r\n    arraySizeVec4\r\n  );\r\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\r\n    arraySizeVec4\r\n  );\r\n\r\n  let startHiLo2D;\r\n  let offsetAndRight2D;\r\n  let startEndNormals2D;\r\n  let texcoordNormalization2D;\r\n\r\n  if (compute2dAttributes) {\r\n    startHiLo2D = new Float32Array(arraySizeVec4);\r\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\r\n    startEndNormals2D = new Float32Array(arraySizeVec4);\r\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\r\n  }\r\n\r\n  /*** Compute total lengths for texture coordinate normalization ***/\r\n  // 2D\r\n  const cartographicsLength = cartographicsArray.length / 2;\r\n  let length2D = 0.0;\r\n\r\n  const startCartographic = startCartographicScratch;\r\n  startCartographic.height = 0.0;\r\n  const endCartographic = endCartographicScratch;\r\n  endCartographic.height = 0.0;\r\n\r\n  let segmentStartCartesian = segmentStartTopScratch;\r\n  let segmentEndCartesian = segmentEndTopScratch;\r\n\r\n  if (compute2dAttributes) {\r\n    index = 0;\r\n    for (i = 1; i < cartographicsLength; i++) {\r\n      // Don't clone anything from previous segment b/c possible IDL touch\r\n      startCartographic.latitude = cartographicsArray[index];\r\n      startCartographic.longitude = cartographicsArray[index + 1];\r\n      endCartographic.latitude = cartographicsArray[index + 2];\r\n      endCartographic.longitude = cartographicsArray[index + 3];\r\n\r\n      segmentStartCartesian = projection.project(\r\n        startCartographic,\r\n        segmentStartCartesian\r\n      );\r\n      segmentEndCartesian = projection.project(\r\n        endCartographic,\r\n        segmentEndCartesian\r\n      );\r\n      length2D += Cartesian3.distance(\r\n        segmentStartCartesian,\r\n        segmentEndCartesian\r\n      );\r\n      index += 2;\r\n    }\r\n  }\r\n\r\n  // 3D\r\n  const positionsLength = topPositionsArray.length / 3;\r\n  segmentEndCartesian = Cartesian3.unpack(\r\n    topPositionsArray,\r\n    0,\r\n    segmentEndCartesian\r\n  );\r\n  let length3D = 0.0;\r\n\r\n  index = 3;\r\n  for (i = 1; i < positionsLength; i++) {\r\n    segmentStartCartesian = Cartesian3.clone(\r\n      segmentEndCartesian,\r\n      segmentStartCartesian\r\n    );\r\n    segmentEndCartesian = Cartesian3.unpack(\r\n      topPositionsArray,\r\n      index,\r\n      segmentEndCartesian\r\n    );\r\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n    index += 3;\r\n  }\r\n\r\n  /*** Generate segments ***/\r\n  let j;\r\n  index = 3;\r\n  let cartographicsIndex = 0;\r\n  let vec2sWriteIndex = 0;\r\n  let vec3sWriteIndex = 0;\r\n  let vec4sWriteIndex = 0;\r\n  let miterBroken = false;\r\n\r\n  let endBottom = Cartesian3.unpack(\r\n    bottomPositionsArray,\r\n    0,\r\n    segmentEndBottomScratch\r\n  );\r\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\r\n  let endGeometryNormal = Cartesian3.unpack(\r\n    normalsArray,\r\n    0,\r\n    segmentEndNormalScratch\r\n  );\r\n\r\n  if (loop) {\r\n    const preEndBottom = Cartesian3.unpack(\r\n      bottomPositionsArray,\r\n      bottomPositionsArray.length - 6,\r\n      segmentStartBottomScratch\r\n    );\r\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\r\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\r\n      endGeometryNormal = Cartesian3.negate(\r\n        endGeometryNormal,\r\n        endGeometryNormal\r\n      );\r\n    }\r\n  }\r\n\r\n  let lengthSoFar3D = 0.0;\r\n  let lengthSoFar2D = 0.0;\r\n\r\n  // For translating bounding volume\r\n  let sumHeights = 0.0;\r\n\r\n  for (i = 0; i < segmentCount; i++) {\r\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\r\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\r\n    let startGeometryNormal = Cartesian3.clone(\r\n      endGeometryNormal,\r\n      segmentStartNormalScratch\r\n    );\r\n\r\n    if (miterBroken) {\r\n      startGeometryNormal = Cartesian3.negate(\r\n        startGeometryNormal,\r\n        startGeometryNormal\r\n      );\r\n    }\r\n\r\n    endBottom = Cartesian3.unpack(\r\n      bottomPositionsArray,\r\n      index,\r\n      segmentEndBottomScratch\r\n    );\r\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\r\n    endGeometryNormal = Cartesian3.unpack(\r\n      normalsArray,\r\n      index,\r\n      segmentEndNormalScratch\r\n    );\r\n\r\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\r\n\r\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\r\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\r\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\r\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\r\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\r\n    let start2D;\r\n    let end2D;\r\n    let startGeometryNormal2D;\r\n    let endGeometryNormal2D;\r\n\r\n    if (compute2dAttributes) {\r\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\r\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\r\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\r\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\r\n      direction2D.y = Math.abs(direction2D.y);\r\n\r\n      startGeometryNormal2D = segmentStartNormal2DScratch;\r\n      endGeometryNormal2D = segmentEndNormal2DScratch;\r\n      if (\r\n        nudgeResult === 0 ||\r\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\r\n      ) {\r\n        // No nudge - project the original normal\r\n        // Or, if the line's angle relative to the IDL is very acute,\r\n        // in which case snapping will produce oddly shaped volumes.\r\n        startGeometryNormal2D = projectNormal(\r\n          projection,\r\n          startCartographic,\r\n          startGeometryNormal,\r\n          start2D,\r\n          segmentStartNormal2DScratch\r\n        );\r\n        endGeometryNormal2D = projectNormal(\r\n          projection,\r\n          endCartographic,\r\n          endGeometryNormal,\r\n          end2D,\r\n          segmentEndNormal2DScratch\r\n        );\r\n      } else if (nudgeResult === 1) {\r\n        // Start is close to IDL - snap start normal to align with IDL\r\n        endGeometryNormal2D = projectNormal(\r\n          projection,\r\n          endCartographic,\r\n          endGeometryNormal,\r\n          end2D,\r\n          segmentEndNormal2DScratch\r\n        );\r\n        startGeometryNormal2D.x = 0.0;\r\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\r\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\r\n        startGeometryNormal2D.y = CesiumMath.sign(\r\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\r\n        );\r\n        startGeometryNormal2D.z = 0.0;\r\n      } else {\r\n        // End is close to IDL - snap end normal to align with IDL\r\n        startGeometryNormal2D = projectNormal(\r\n          projection,\r\n          startCartographic,\r\n          startGeometryNormal,\r\n          start2D,\r\n          segmentStartNormal2DScratch\r\n        );\r\n        endGeometryNormal2D.x = 0.0;\r\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\r\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\r\n        endGeometryNormal2D.y = CesiumMath.sign(\r\n          startCartographic.longitude - endCartographic.longitude\r\n        );\r\n        endGeometryNormal2D.z = 0.0;\r\n      }\r\n    }\r\n\r\n    /****************************************\r\n     * Geometry descriptors of a \"line on terrain,\"\r\n     * as opposed to the \"shadow volume used to draw\r\n     * the line on terrain\":\r\n     * - position of start + offset to end\r\n     * - start, end, and right-facing planes\r\n     * - encoded texture coordinate offsets\r\n     ****************************************/\r\n\r\n    /* 3D */\r\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\r\n\r\n    const encodedStart = EncodedCartesian3.fromCartesian(\r\n      startBottom,\r\n      encodeScratch\r\n    );\r\n    const forwardOffset = Cartesian3.subtract(\r\n      endBottom,\r\n      startBottom,\r\n      offsetScratch\r\n    );\r\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\r\n\r\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\r\n    startUp = Cartesian3.normalize(startUp, startUp);\r\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\r\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\r\n\r\n    let startPlaneNormal = Cartesian3.cross(\r\n      startUp,\r\n      startGeometryNormal,\r\n      startPlaneNormalScratch\r\n    );\r\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\r\n\r\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\r\n    endUp = Cartesian3.normalize(endUp, endUp);\r\n    let endPlaneNormal = Cartesian3.cross(\r\n      endGeometryNormal,\r\n      endUp,\r\n      endPlaneNormalScratch\r\n    );\r\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\r\n\r\n    const texcoordNormalization3DX = segmentLength3D / length3D;\r\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\r\n\r\n    /* 2D */\r\n    let segmentLength2D = 0.0;\r\n    let encodedStart2D;\r\n    let forwardOffset2D;\r\n    let right2D;\r\n    let texcoordNormalization2DX = 0.0;\r\n    let texcoordNormalization2DY = 0.0;\r\n    if (compute2dAttributes) {\r\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\r\n\r\n      encodedStart2D = EncodedCartesian3.fromCartesian(\r\n        start2D,\r\n        encodeScratch2D\r\n      );\r\n      forwardOffset2D = Cartesian3.subtract(\r\n        end2D,\r\n        start2D,\r\n        forwardOffset2DScratch\r\n      );\r\n\r\n      // Right direction is just forward direction rotated by -90 degrees around Z\r\n      // Similarly with plane normals\r\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\r\n      const swap = right2D.x;\r\n      right2D.x = right2D.y;\r\n      right2D.y = -swap;\r\n\r\n      texcoordNormalization2DX = segmentLength2D / length2D;\r\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\r\n    }\r\n    /** Pack **/\r\n    for (j = 0; j < 8; j++) {\r\n      const vec4Index = vec4sWriteIndex + j * 4;\r\n      const vec2Index = vec2sWriteIndex + j * 2;\r\n      const wIndex = vec4Index + 3;\r\n\r\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\r\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\r\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\r\n      const topBottomSide =\r\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\r\n\r\n      // 3D\r\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\r\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\r\n\r\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\r\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\r\n\r\n      Cartesian3.pack(\r\n        startPlaneNormal,\r\n        startNormalAndForwardOffsetZ,\r\n        vec4Index\r\n      );\r\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\r\n\r\n      Cartesian3.pack(\r\n        endPlaneNormal,\r\n        endNormalAndTextureCoordinateNormalizationX,\r\n        vec4Index\r\n      );\r\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\r\n        texcoordNormalization3DX * rightPlaneSide;\r\n\r\n      Cartesian3.pack(\r\n        rightNormal,\r\n        rightNormalAndTextureCoordinateNormalizationY,\r\n        vec4Index\r\n      );\r\n\r\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\r\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n        texcoordNormalization = 9.0; // some value greater than 1.0\r\n      }\r\n      rightNormalAndTextureCoordinateNormalizationY[\r\n        wIndex\r\n      ] = texcoordNormalization;\r\n\r\n      // 2D\r\n      if (compute2dAttributes) {\r\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\r\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\r\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\r\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\r\n\r\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\r\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\r\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\r\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\r\n\r\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\r\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\r\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\r\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\r\n\r\n        texcoordNormalization2D[vec2Index] =\r\n          texcoordNormalization2DX * rightPlaneSide;\r\n\r\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\r\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n          texcoordNormalization = 9.0; // some value greater than 1.0\r\n        }\r\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\r\n      }\r\n    }\r\n\r\n    // Adjust height of volume in 3D\r\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\r\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\r\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\r\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\r\n\r\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\r\n      getHeightCartographics,\r\n      getHeightRectangleScratch\r\n    );\r\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\r\n      getHeightsRectangle,\r\n      ellipsoid\r\n    );\r\n    const minHeight = minMaxHeights.minimumTerrainHeight;\r\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\r\n\r\n    sumHeights += minHeight;\r\n    sumHeights += maxHeight;\r\n\r\n    adjustHeights(\r\n      startBottom,\r\n      startTop,\r\n      minHeight,\r\n      maxHeight,\r\n      adjustHeightStartBottom,\r\n      adjustHeightStartTop\r\n    );\r\n    adjustHeights(\r\n      endBottom,\r\n      endTop,\r\n      minHeight,\r\n      maxHeight,\r\n      adjustHeightEndBottom,\r\n      adjustHeightEndTop\r\n    );\r\n\r\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\r\n    let normalNudge = Cartesian3.multiplyByScalar(\r\n      rightNormal,\r\n      CesiumMath.EPSILON5,\r\n      normalNudgeScratch\r\n    );\r\n    Cartesian3.add(\r\n      adjustHeightStartBottom,\r\n      normalNudge,\r\n      adjustHeightStartBottom\r\n    );\r\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\r\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\r\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\r\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\r\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\r\n\r\n    normalNudge = Cartesian3.multiplyByScalar(\r\n      rightNormal,\r\n      -2.0 * CesiumMath.EPSILON5,\r\n      normalNudgeScratch\r\n    );\r\n    Cartesian3.add(\r\n      adjustHeightStartBottom,\r\n      normalNudge,\r\n      adjustHeightStartBottom\r\n    );\r\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n    Cartesian3.pack(\r\n      adjustHeightStartBottom,\r\n      positionsArray,\r\n      vec3sWriteIndex + 12\r\n    );\r\n    Cartesian3.pack(\r\n      adjustHeightEndBottom,\r\n      positionsArray,\r\n      vec3sWriteIndex + 15\r\n    );\r\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\r\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\r\n\r\n    cartographicsIndex += 2;\r\n    index += 3;\r\n\r\n    vec2sWriteIndex += 16;\r\n    vec3sWriteIndex += 24;\r\n    vec4sWriteIndex += 32;\r\n\r\n    lengthSoFar3D += segmentLength3D;\r\n    lengthSoFar2D += segmentLength2D;\r\n  }\r\n\r\n  index = 0;\r\n  let indexOffset = 0;\r\n  for (i = 0; i < segmentCount; i++) {\r\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\r\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\r\n    }\r\n    indexOffset += 8;\r\n    index += REFERENCE_INDICES_LENGTH;\r\n  }\r\n\r\n  const boundingSpheres = scratchBoundingSpheres;\r\n  BoundingSphere.fromVertices(\r\n    bottomPositionsArray,\r\n    Cartesian3.ZERO,\r\n    3,\r\n    boundingSpheres[0]\r\n  );\r\n  BoundingSphere.fromVertices(\r\n    topPositionsArray,\r\n    Cartesian3.ZERO,\r\n    3,\r\n    boundingSpheres[1]\r\n  );\r\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\r\n\r\n  // Adjust bounding sphere height and radius to cover more of the volume\r\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\r\n\r\n  const attributes = {\r\n    position: new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.DOUBLE,\r\n      componentsPerAttribute: 3,\r\n      normalize: false,\r\n      values: positionsArray,\r\n    }),\r\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\r\n      startHiAndForwardOffsetX\r\n    ),\r\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\r\n      startLoAndForwardOffsetY\r\n    ),\r\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\r\n      startNormalAndForwardOffsetZ\r\n    ),\r\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\r\n      endNormalAndTextureCoordinateNormalizationX\r\n    ),\r\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\r\n      rightNormalAndTextureCoordinateNormalizationY\r\n    ),\r\n  };\r\n\r\n  if (compute2dAttributes) {\r\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\r\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\r\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\r\n    attributes.texcoordNormalization2D = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.FLOAT,\r\n      componentsPerAttribute: 2,\r\n      normalize: false,\r\n      values: texcoordNormalization2D,\r\n    });\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: indices,\r\n    boundingSphere: boundingSphere,\r\n  });\r\n}\r\n\r\nfunction getVec4GeometryAttribute(typedArray) {\r\n  return new GeometryAttribute({\r\n    componentDatatype: ComponentDatatype.FLOAT,\r\n    componentsPerAttribute: 4,\r\n    normalize: false,\r\n    values: typedArray,\r\n  });\r\n}\r\n\r\n/**\r\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\r\n * Exposed for testing.\r\n *\r\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\r\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\r\n *   Used to check if the normal crosses the IDL during projection.\r\n * @param {Cartesian3} normal The normal in 3D.\r\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\r\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\r\n * @private\r\n */\r\nGroundPolylineGeometry._projectNormal = projectNormal;\r\nexport default GroundPolylineGeometry;\r\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\r\nimport defined from \"../Core/defined.js\";\r\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\r\n\r\nfunction createGroundPolylineGeometry(groundPolylineGeometry, offset) {\r\n  return ApproximateTerrainHeights.initialize().then(function () {\r\n    if (defined(offset)) {\r\n      groundPolylineGeometry = GroundPolylineGeometry.unpack(\r\n        groundPolylineGeometry,\r\n        offset\r\n      );\r\n    }\r\n    return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\r\n  });\r\n}\r\nexport default createGroundPolylineGeometry;\r\n"],"names":["defaultValue","Ellipsoid","Rectangle","GeographicProjection","Check","CesiumMath","defined","Cartesian2","Cartesian3","Cartographic","BoundingSphere","Resource","buildModuleUrl","DeveloperError","WebMercatorProjection","ArcType","EllipsoidGeodesic","EllipsoidRhumbLine","Plane","IntersectionTests","arrayRemoveDuplicates","Matrix3","Quaternion","EncodedCartesian3","ApproximateTerrainHeights","GeometryAttribute","ComponentDatatype","Geometry"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;EASA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAAS,sBAAsB,CAAC,OAAO,EAAE;EACzC,EAAE,OAAO,GAAGA,yBAAY,CAAC,OAAO,EAAEA,yBAAY,CAAC,YAAY,CAAC,CAAC;AAC7D;EACA,EAAE,IAAI,CAAC,UAAU,GAAGA,yBAAY,CAAC,OAAO,CAAC,SAAS,EAAEC,iBAAS,CAAC,KAAK,CAAC,CAAC;EACrE,EAAE,IAAI,CAAC,UAAU,GAAGD,yBAAY,CAAC,OAAO,CAAC,SAAS,EAAEE,iBAAS,CAAC,SAAS,CAAC,CAAC;EACzE,EAAE,IAAI,CAAC,WAAW,GAAG,IAAIC,+BAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;EAC/D,EAAE,IAAI,CAAC,wBAAwB,GAAGH,yBAAY;EAC9C,IAAI,OAAO,CAAC,uBAAuB;EACnC,IAAI,CAAC;EACL,GAAG,CAAC;EACJ,EAAE,IAAI,CAAC,wBAAwB,GAAGA,yBAAY;EAC9C,IAAI,OAAO,CAAC,uBAAuB;EACnC,IAAI,CAAC;EACL,GAAG,CAAC;EACJ,CAAC;AACD;EACA,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,SAAS,EAAE;EAC1D;EACA;EACA;EACA;EACA;EACA,EAAE,SAAS,EAAE;EACb,IAAI,GAAG,EAAE,YAAY;EACrB,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;EAC7B,KAAK;EACL,GAAG;AACH;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,SAAS,EAAE;EACb,IAAI,GAAG,EAAE,YAAY;EACrB,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;EAC7B,KAAK;EACL,GAAG;AACH;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,UAAU,EAAE;EACd,IAAI,GAAG,EAAE,YAAY;EACrB,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC;EAC9B,KAAK;EACL,GAAG;EACH,CAAC,CAAC,CAAC;AACH;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,wBAAwB,GAAG,UAAU,KAAK,EAAE;EAC7E,EAAE,OAAO,IAAI,CAAC,wBAAwB,IAAI,KAAK,CAAC;EAChD,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,wBAAwB,GAAG,UAAU,KAAK,EAAE;EAC7E,EAAE,OAAO,IAAI,CAAC,wBAAwB,IAAI,KAAK,CAAC;EAChD,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,0BAA0B,GAAG;EAC9D,EAAE,SAAS;EACX,EAAE,MAAM;EACR,EAAE;EACF;EACA,EAAEI,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;EACxC;AACA;EACA,EAAE,MAAM,IAAI,GAAGC,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;EACpD,EAAE,MAAM,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EACtD,EAAE,MAAM,IAAI,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;EACpD,EAAE,MAAM,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AACtD;EACA,EAAE,IAAI,CAACC,oBAAO,CAAC,MAAM,CAAC,EAAE;EACxB,IAAI,OAAO,IAAIJ,iBAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;EACnD,GAAG;AACH;EACA,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;EACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;EACvB,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;EACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;EACvB,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,uBAAuB,GAAG;EAC3D,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,KAAK;EACP,EAAE,MAAM;EACR,EAAE;EACF,EAAE,MAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;EACvE,EAAE,gBAAgB,CAAC,IAAI,GAAGG,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;EACtE,EAAE,gBAAgB,CAAC,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;EACxE,EAAE,gBAAgB,CAAC,IAAI,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;EACtE,EAAE,gBAAgB,CAAC,KAAK,GAAGA,iBAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;EACxE,EAAE,OAAO,gBAAgB,CAAC;EAC1B,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,iBAAiB,GAAG;EACrD,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,KAAK;EACP,EAAE,MAAM;EACR,EAAE;EACF,EAAE,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;AACpC;EACA,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;EACtD,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;AACtD;EACA,EAAE,MAAM,UAAU,GAAG,SAAS,CAAC,KAAK,GAAG,MAAM,CAAC;EAC9C,EAAE,MAAM,IAAI,GAAG,CAAC,GAAG,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC;EAC/C,EAAE,MAAM,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC;AACrD;EACA,EAAE,MAAM,WAAW,GAAG,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;EAChD,EAAE,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,CAAC,GAAG,WAAW,CAAC;EAClD,EAAE,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,WAAW,CAAC;AACxD;EACA,EAAE,IAAI,CAACC,oBAAO,CAAC,MAAM,CAAC,EAAE;EACxB,IAAI,MAAM,GAAG,IAAIJ,iBAAS,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;EACrD,GAAG;AACH;EACA,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;EACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;EACvB,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;EACrB,EAAE,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;EACvB,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,SAAS,CAAC,gBAAgB,GAAG;EACpD,EAAE,QAAQ;EACV,EAAE,KAAK;EACP,EAAE,MAAM;EACR,EAAE;EACF,EAAE,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;EACpC,EAAE,IAAI,CAACA,iBAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE;EAChD;EACA,IAAI,OAAO,SAAS,CAAC;EACrB,GAAG;AACH;EACA,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;EACtD,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;AACtD;EACA,EAAE,MAAM,UAAU,GAAG,SAAS,CAAC,KAAK,GAAG,MAAM,CAAC;EAC9C,EAAE,MAAM,WAAW,GAAG,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;AAChD;EACA,EAAE,IAAI,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;EACrC,EAAE,IAAI,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,EAAE;EACvC,IAAI,SAAS,IAAIG,iBAAU,CAAC,MAAM,CAAC;EACnC,GAAG;AACH;EACA,EAAE,IAAI,eAAe,GAAG,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC,IAAI,IAAI,UAAU,IAAI,CAAC,CAAC;EACxE,EAAE,IAAI,eAAe,IAAI,MAAM,EAAE;EACjC,IAAI,eAAe,GAAG,MAAM,GAAG,CAAC,CAAC;EACjC,GAAG;AACH;EACA,EAAE,IAAI,eAAe;EACrB,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,GAAG,QAAQ,CAAC,QAAQ,IAAI,WAAW,IAAI,CAAC,CAAC;EAC9D,EAAE,IAAI,eAAe,IAAI,MAAM,EAAE;EACjC,IAAI,eAAe,GAAG,MAAM,GAAG,CAAC,CAAC;EACjC,GAAG;AACH;EACA,EAAE,IAAI,CAACC,oBAAO,CAAC,MAAM,CAAC,EAAE;EACxB,IAAI,OAAO,IAAIC,kBAAU,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;EAC5D,GAAG;AACH;EACA,EAAE,MAAM,CAAC,CAAC,GAAG,eAAe,CAAC;EAC7B,EAAE,MAAM,CAAC,CAAC,GAAG,eAAe,CAAC;EAC7B,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC;;EC3OD,MAAM,0BAA0B,GAAG,IAAIC,kBAAU,EAAE,CAAC;EACpD,MAAM,0BAA0B,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACpD,MAAM,2BAA2B,GAAG,IAAIC,oBAAY,EAAE,CAAC;EACvD,MAAM,sBAAsB,GAAG,IAAID,kBAAU,EAAE,CAAC;EAChD,MAAM,uBAAuB,GAAG,IAAIA,kBAAU,EAAE,CAAC;AACjD;EACA,MAAM,qBAAqB,GAAG,IAAIE,yBAAc,EAAE,CAAC;EACnD,MAAM,YAAY,GAAG,IAAI,sBAAsB,EAAE,CAAC;EAClD,MAAM,cAAc,GAAG;EACvB,EAAE,IAAID,oBAAY,EAAE;EACpB,EAAE,IAAIA,oBAAY,EAAE;EACpB,EAAE,IAAIA,oBAAY,EAAE;EACpB,EAAE,IAAIA,oBAAY,EAAE;EACpB,CAAC,CAAC;EACF,MAAM,aAAa,GAAG,IAAIF,kBAAU,EAAE,CAAC;AACvC;EACA;EACA;EACA;EACA;EACA,MAAM,yBAAyB,GAAG,EAAE,CAAC;AACrC;EACA;EACA;EACA;EACA;EACA,yBAAyB,CAAC,UAAU,GAAG,YAAY;EACnD,EAAE,IAAI,WAAW,GAAG,yBAAyB,CAAC,YAAY,CAAC;EAC3D,EAAE,IAAID,oBAAO,CAAC,WAAW,CAAC,EAAE;EAC5B,IAAI,OAAO,WAAW,CAAC;EACvB,GAAG;AACH;EACA,EAAE,WAAW,GAAGK,mBAAQ,CAAC,SAAS;EAClC,IAAIC,yBAAc,CAAC,uCAAuC,CAAC;EAC3D,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE;EACzB,IAAI,yBAAyB,CAAC,eAAe,GAAG,IAAI,CAAC;EACrD,GAAG,CAAC,CAAC;EACL,EAAE,yBAAyB,CAAC,YAAY,GAAG,WAAW,CAAC;AACvD;EACA,EAAE,OAAO,WAAW,CAAC;EACrB,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA,yBAAyB,CAAC,wBAAwB,GAAG;EACrD,EAAE,SAAS;EACX,EAAE,SAAS;EACX,EAAE;EACF;EACA,EAAER,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;EACxC,EAAE,IAAI,CAACE,oBAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,EAAE;EAC3D,IAAI,MAAM,IAAIO,oBAAc;EAC5B,MAAM,mHAAmH;EACzH,KAAK,CAAC;EACN,GAAG;EACH;EACA,EAAE,SAAS,GAAGb,yBAAY,CAAC,SAAS,EAAEC,iBAAS,CAAC,KAAK,CAAC,CAAC;AACvD;EACA,EAAE,MAAM,OAAO,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC;AAC5C;EACA;EACA,EAAE,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;EAC5E,EAAE,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;EAC5E,EAAE,IAAIK,oBAAO,CAAC,OAAO,CAAC,EAAE;EACxB,IAAI,MAAM,GAAG,GAAG,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7D,IAAI,MAAM,OAAO,GAAG,yBAAyB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;EACnE,IAAI,IAAIA,oBAAO,CAAC,OAAO,CAAC,EAAE;EAC1B,MAAM,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;EACpC,MAAM,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;EACpC,KAAK;AACL;EACA;EACA,IAAI,SAAS,CAAC,uBAAuB;EACrC,MAAMJ,iBAAS,CAAC,SAAS,CAAC,SAAS,EAAE,2BAA2B,CAAC;EACjE,MAAM,0BAA0B;EAChC,KAAK,CAAC;EACN,IAAI,SAAS,CAAC,uBAAuB;EACrC,MAAMA,iBAAS,CAAC,SAAS,CAAC,SAAS,EAAE,2BAA2B,CAAC;EACjE,MAAM,0BAA0B;EAChC,KAAK,CAAC;AACN;EACA,IAAIM,kBAAU,CAAC,QAAQ;EACvB,MAAM,0BAA0B;EAChC,MAAM,0BAA0B;EAChC,MAAM,sBAAsB;EAC5B,KAAK,CAAC;EACN,IAAI,MAAM,eAAe,GAAG,SAAS,CAAC,sBAAsB;EAC5D,MAAM,sBAAsB;EAC5B,MAAM,uBAAuB;EAC7B,KAAK,CAAC;EACN,IAAI,IAAIF,oBAAO,CAAC,eAAe,CAAC,EAAE;EAClC,MAAM,MAAM,QAAQ,GAAGE,kBAAU,CAAC,QAAQ;EAC1C,QAAQ,sBAAsB;EAC9B,QAAQ,eAAe;EACvB,OAAO,CAAC;EACR,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC,QAAQ,CAAC,CAAC;EAC/D,KAAK,MAAM;EACX,MAAM,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;EAC5E,KAAK;EACL,GAAG;AACH;EACA,EAAE,gBAAgB,GAAG,IAAI,CAAC,GAAG;EAC7B,IAAI,yBAAyB,CAAC,wBAAwB;EACtD,IAAI,gBAAgB;EACpB,GAAG,CAAC;AACJ;EACA,EAAE,OAAO;EACT,IAAI,oBAAoB,EAAE,gBAAgB;EAC1C,IAAI,oBAAoB,EAAE,gBAAgB;EAC1C,GAAG,CAAC;EACJ,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,SAAS,EAAE,SAAS,EAAE;EAC9E;EACA,EAAEJ,WAAK,CAAC,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;EACxC,EAAE,IAAI,CAACE,oBAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,EAAE;EAC3D,IAAI,MAAM,IAAIO,oBAAc;EAC5B,MAAM,mHAAmH;EACzH,KAAK,CAAC;EACN,GAAG;EACH;EACA,EAAE,SAAS,GAAGb,yBAAY,CAAC,SAAS,EAAEC,iBAAS,CAAC,KAAK,CAAC,CAAC;AACvD;EACA,EAAE,MAAM,OAAO,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC;AAC5C;EACA;EACA,EAAE,IAAI,gBAAgB,GAAG,yBAAyB,CAAC,wBAAwB,CAAC;EAC5E,EAAE,IAAIK,oBAAO,CAAC,OAAO,CAAC,EAAE;EACxB,IAAI,MAAM,GAAG,GAAG,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7D,IAAI,MAAM,OAAO,GAAG,yBAAyB,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;EACnE,IAAI,IAAIA,oBAAO,CAAC,OAAO,CAAC,EAAE;EAC1B,MAAM,gBAAgB,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;EACpC,KAAK;EACL,GAAG;AACH;EACA,EAAE,MAAM,MAAM,GAAGI,yBAAc,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;EAC3E,EAAEA,yBAAc,CAAC,eAAe;EAChC,IAAI,SAAS;EACb,IAAI,SAAS;EACb,IAAI,gBAAgB;EACpB,IAAI,qBAAqB;EACzB,GAAG,CAAC;AACJ;EACA,EAAE,OAAOA,yBAAc,CAAC,KAAK,CAAC,MAAM,EAAE,qBAAqB,EAAE,MAAM,CAAC,CAAC;EACrE,CAAC,CAAC;AACF;EACA,SAAS,cAAc,CAAC,SAAS,EAAE;EACnC,EAAED,oBAAY,CAAC,WAAW;EAC1B,IAAI,SAAS,CAAC,IAAI;EAClB,IAAI,SAAS,CAAC,KAAK;EACnB,IAAI,GAAG;EACP,IAAI,cAAc,CAAC,CAAC,CAAC;EACrB,GAAG,CAAC;EACJ,EAAEA,oBAAY,CAAC,WAAW;EAC1B,IAAI,SAAS,CAAC,IAAI;EAClB,IAAI,SAAS,CAAC,KAAK;EACnB,IAAI,GAAG;EACP,IAAI,cAAc,CAAC,CAAC,CAAC;EACrB,GAAG,CAAC;EACJ,EAAEA,oBAAY,CAAC,WAAW;EAC1B,IAAI,SAAS,CAAC,IAAI;EAClB,IAAI,SAAS,CAAC,KAAK;EACnB,IAAI,GAAG;EACP,IAAI,cAAc,CAAC,CAAC,CAAC;EACrB,GAAG,CAAC;EACJ,EAAEA,oBAAY,CAAC,WAAW;EAC1B,IAAI,SAAS,CAAC,IAAI;EAClB,IAAI,SAAS,CAAC,KAAK;EACnB,IAAI,GAAG;EACP,IAAI,cAAc,CAAC,CAAC,CAAC;EACrB,GAAG,CAAC;AACJ;EACA;EACA,EAAE,IAAI,UAAU,GAAG,CAAC;EACpB,IAAI,UAAU,GAAG,CAAC,CAAC;EACnB,EAAE,IAAI,QAAQ,GAAG,CAAC;EAClB,IAAI,QAAQ,GAAG,CAAC,CAAC;EACjB,EAAE,MAAM,QAAQ,GAAG,yBAAyB,CAAC,uBAAuB,CAAC;EACrE,EAAE,IAAI,CAAC,CAAC;EACR,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,EAAE,CAAC,EAAE;EAClC,IAAI,IAAI,MAAM,GAAG,KAAK,CAAC;EACvB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;EAChC,MAAM,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;EACvC,MAAM,YAAY,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,aAAa,CAAC,CAAC;EAC9D,MAAM,IAAI,CAAC,KAAK,CAAC,EAAE;EACnB,QAAQ,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;EACnC,QAAQ,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;EACnC,OAAO,MAAM,IAAI,QAAQ,KAAK,aAAa,CAAC,CAAC,IAAI,QAAQ,KAAK,aAAa,CAAC,CAAC,EAAE;EAC/E,QAAQ,MAAM,GAAG,IAAI,CAAC;EACtB,QAAQ,MAAM;EACd,OAAO;EACP,KAAK;AACL;EACA,IAAI,IAAI,MAAM,EAAE;EAChB,MAAM,MAAM;EACZ,KAAK;AACL;EACA,IAAI,UAAU,GAAG,QAAQ,CAAC;EAC1B,IAAI,UAAU,GAAG,QAAQ,CAAC;EAC1B,GAAG;AACH;EACA,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;EACf,IAAI,OAAO,SAAS,CAAC;EACrB,GAAG;AACH;EACA,EAAE,OAAO;EACT,IAAI,CAAC,EAAE,UAAU;EACjB,IAAI,CAAC,EAAE,UAAU;EACjB,IAAI,KAAK,EAAE,CAAC,GAAG,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,CAAC;EAC1C,GAAG,CAAC;EACJ,CAAC;AACD;EACA,yBAAyB,CAAC,uBAAuB,GAAG,CAAC,CAAC;EACtD,yBAAyB,CAAC,wBAAwB,GAAG,MAAM,CAAC;EAC5D,yBAAyB,CAAC,wBAAwB,GAAG,CAAC,QAAQ,CAAC;EAC/D,yBAAyB,CAAC,eAAe,GAAG,SAAS,CAAC;EACtD,yBAAyB,CAAC,YAAY,GAAG,SAAS,CAAC;AACnD;EACA,MAAM,CAAC,gBAAgB,CAAC,yBAAyB,EAAE;EACnD;EACA;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,WAAW,EAAE;EACf,IAAI,GAAG,EAAE,YAAY;EACrB,MAAM,OAAOH,oBAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,CAAC;EAChE,KAAK;EACL,GAAG;EACH,CAAC,CAAC,CAAC;AACH,oCAAe,yBAAyB;;ECtOxC,MAAM,WAAW,GAAG,CAACH,+BAAoB,EAAEW,2CAAqB,CAAC,CAAC;EAClE,MAAM,gBAAgB,GAAG,WAAW,CAAC,MAAM,CAAC;AAC5C;EACA,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAACT,iBAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;EAC/D,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAACA,iBAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAChE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,uBAAuB,GAAG,GAAG,CAAC;EACpC,MAAM,uBAAuB,GAAG,MAAM,CAAC;AACvC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAAS,sBAAsB,CAAC,OAAO,EAAE;EACzC,EAAE,OAAO,GAAGL,yBAAY,CAAC,OAAO,EAAEA,yBAAY,CAAC,YAAY,CAAC,CAAC;EAC7D,EAAE,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;AACtC;EACA;EACA,EAAE,IAAI,CAACM,oBAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;EACnD,IAAI,MAAM,IAAIO,oBAAc,CAAC,sCAAsC,CAAC,CAAC;EACrE,GAAG;EACH,EAAE;EACF,IAAIP,oBAAO,CAAC,OAAO,CAAC,OAAO,CAAC;EAC5B,IAAI,OAAO,CAAC,OAAO,KAAKS,eAAO,CAAC,QAAQ;EACxC,IAAI,OAAO,CAAC,OAAO,KAAKA,eAAO,CAAC,KAAK;EACrC,IAAI;EACJ,IAAI,MAAM,IAAIF,oBAAc;EAC5B,MAAM,mEAAmE;EACzE,KAAK,CAAC;EACN,GAAG;EACH;AACA;EACA;EACA;EACA;EACA;EACA,EAAE,IAAI,CAAC,KAAK,GAAGb,yBAAY,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAChD;EACA,EAAE,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;AAC9B;EACA;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,IAAI,CAAC,WAAW,GAAGA,yBAAY,CAAC,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;AAC/D;EACA;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,IAAI,CAAC,IAAI,GAAGA,yBAAY,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAChD;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,IAAI,CAAC,OAAO,GAAGA,yBAAY,CAAC,OAAO,CAAC,OAAO,EAAEe,eAAO,CAAC,QAAQ,CAAC,CAAC;AACjE;EACA,EAAE,IAAI,CAAC,UAAU,GAAGd,iBAAS,CAAC,KAAK,CAAC;AACpC;EACA;EACA,EAAE,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;EAC5B,EAAE,IAAI,CAAC,WAAW,GAAG,8BAA8B,CAAC;AACpD;EACA;EACA,EAAE,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;EAC5B,CAAC;AACD;EACA,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,SAAS,EAAE;EAC1D;EACA;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,YAAY,EAAE;EAChB,IAAI,GAAG,EAAE,YAAY;EACrB,MAAM;EACN,QAAQ,GAAG;EACX,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;EAClC,QAAQ,GAAG;EACX,QAAQ,GAAG;EACX,QAAQ,GAAG;EACX,QAAQA,iBAAS,CAAC,YAAY;EAC9B,QAAQ,GAAG;EACX,QAAQ,GAAG;EACX,QAAQ;EACR,KAAK;EACL,GAAG;EACH,CAAC,CAAC,CAAC;AACH;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,yBAAyB,GAAG;EACnD,EAAE,sBAAsB;EACxB,EAAE,aAAa;EACf,EAAE;EACF,EAAE,IAAI,eAAe,GAAG,CAAC,CAAC;EAC1B,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,EAAE,CAAC,EAAE,EAAE;EAC7C,IAAI,IAAI,aAAa,YAAY,WAAW,CAAC,CAAC,CAAC,EAAE;EACjD,MAAM,eAAe,GAAG,CAAC,CAAC;EAC1B,MAAM,MAAM;EACZ,KAAK;EACL,GAAG;AACH;EACA,EAAE,sBAAsB,CAAC,gBAAgB,GAAG,eAAe,CAAC;EAC5D,EAAE,sBAAsB,CAAC,UAAU,GAAG,aAAa,CAAC,SAAS,CAAC;EAC9D,CAAC,CAAC;AACF;EACA,MAAM,aAAa,GAAG,IAAIO,kBAAU,EAAE,CAAC;EACvC,MAAM,aAAa,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACvC,MAAM,aAAa,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACvC,SAAS,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE;EACtE,EAAE,MAAM,WAAW,GAAG,WAAW,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;EACxE,EAAE,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;EAC3E,EAAE,MAAM,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;AACpE;EACA,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC,QAAQ,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;EAC7D,EAAE,MAAM,OAAO,GAAG,SAAS,CAAC,SAAS,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;AACnE;EACA,EAAEA,kBAAU,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;EACxC,EAAE,OAAOA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAC9C,CAAC;AACD;EACA,MAAM,+BAA+B,GAAG,IAAIC,oBAAY,EAAE,CAAC;EAC3D,MAAM,yBAAyB,GAAG,IAAID,kBAAU,EAAE,CAAC;EACnD,MAAM,sBAAsB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAChD,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,SAAS,kBAAkB;EAC3B,EAAE,KAAK;EACP,EAAE,GAAG;EACL,EAAE,SAAS;EACX,EAAE,SAAS;EACX,EAAE,WAAW;EACb,EAAE,OAAO;EACT,EAAE,SAAS;EACX,EAAE,YAAY;EACd,EAAE,oBAAoB;EACtB,EAAE,iBAAiB;EACnB,EAAE,kBAAkB;EACpB,EAAE;EACF,EAAE,IAAI,WAAW,KAAK,GAAG,EAAE;EAC3B,IAAI,OAAO;EACX,GAAG;AACH;EACA,EAAE,IAAI,aAAa,CAAC;EACpB,EAAE,IAAI,OAAO,KAAKO,eAAO,CAAC,QAAQ,EAAE;EACpC,IAAI,aAAa,GAAG,IAAIC,mCAAiB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;EACjE,GAAG,MAAM,IAAI,OAAO,KAAKD,eAAO,CAAC,KAAK,EAAE;EACxC,IAAI,aAAa,GAAG,IAAIE,qCAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;EAClE,GAAG;AACH;EACA,EAAE,MAAM,eAAe,GAAG,aAAa,CAAC,eAAe,CAAC;EACxD,EAAE,IAAI,eAAe,GAAG,WAAW,EAAE;EACrC,IAAI,OAAO;EACX,GAAG;AACH;EACA;EACA,EAAE,MAAM,kBAAkB,GAAG,kBAAkB;EAC/C,IAAI,KAAK;EACT,IAAI,GAAG;EACP,IAAI,SAAS;EACb,IAAI,SAAS;EACb,IAAI,yBAAyB;EAC7B,GAAG,CAAC;AACJ;EACA,EAAE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC;EAC5D,EAAE,MAAM,kBAAkB,GAAG,eAAe,GAAG,QAAQ,CAAC;EACxD,EAAE,IAAI,iBAAiB,GAAG,kBAAkB,CAAC;EAC7C,EAAE,MAAM,WAAW,GAAG,QAAQ,GAAG,CAAC,CAAC;EACnC,EAAE,IAAI,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC;EACtC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;EACxC,IAAI,MAAM,wBAAwB,GAAG,aAAa,CAAC,+BAA+B;EAClF,MAAM,iBAAiB;EACvB,MAAM,+BAA+B;EACrC,KAAK,CAAC;EACN,IAAI,MAAM,kBAAkB,GAAG,WAAW;EAC1C,MAAM,SAAS;EACf,MAAM,wBAAwB;EAC9B,MAAM,SAAS;EACf,MAAM,yBAAyB;EAC/B,KAAK,CAAC;EACN,IAAI,MAAM,eAAe,GAAG,WAAW;EACvC,MAAM,SAAS;EACf,MAAM,wBAAwB;EAC9B,MAAM,SAAS;EACf,MAAM,sBAAsB;EAC5B,KAAK,CAAC;AACN;EACA,IAAIT,kBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;EACjE,IAAIA,kBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,SAAS,CAAC,CAAC;EACzE,IAAIA,kBAAU,CAAC,IAAI,CAAC,eAAe,EAAE,iBAAiB,EAAE,SAAS,CAAC,CAAC;EACnE,IAAI,kBAAkB,CAAC,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,CAAC;EAC/D,IAAI,kBAAkB,CAAC,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;AAChE;EACA,IAAI,SAAS,IAAI,CAAC,CAAC;EACnB,IAAI,iBAAiB,IAAI,kBAAkB,CAAC;EAC5C,GAAG;EACH,CAAC;AACD;EACA,MAAM,6BAA6B,GAAG,IAAIC,oBAAY,EAAE,CAAC;EACzD,SAAS,WAAW,CAAC,SAAS,EAAE,YAAY,EAAE,MAAM,EAAE,MAAM,EAAE;EAC9D,EAAEA,oBAAY,CAAC,KAAK,CAAC,YAAY,EAAE,6BAA6B,CAAC,CAAC;EAClE,EAAE,6BAA6B,CAAC,MAAM,GAAG,MAAM,CAAC;EAChD,EAAE,OAAOA,oBAAY,CAAC,WAAW;EACjC,IAAI,6BAA6B;EACjC,IAAI,SAAS;EACb,IAAI,MAAM;EACV,GAAG,CAAC;EACJ,CAAC;AACD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,IAAI,GAAG,UAAU,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE;EACrE;EACA,EAAEL,WAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;EACtC,EAAEA,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;EAChC;AACA;EACA,EAAE,IAAI,KAAK,GAAGJ,yBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;AAC7C;EACA,EAAE,MAAM,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC;EACrC,EAAE,MAAM,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;AAC3C;EACA,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,eAAe,CAAC;AACnC;EACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,EAAE,CAAC,EAAE;EAC5C,IAAI,MAAM,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;EACnC,IAAIQ,kBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EAC7C,IAAI,KAAK,IAAI,CAAC,CAAC;EACf,GAAG;AACH;EACA,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC;EACrC,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;EAC1C,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC;AACjC;EACA,EAAEP,iBAAS,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EACjD,EAAE,KAAK,IAAIA,iBAAS,CAAC,YAAY,CAAC;AAClC;EACA,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,gBAAgB,CAAC;EAC1C,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,YAAY,GAAG,GAAG,GAAG,GAAG,CAAC;AAClD;EACA,EAAE,OAAO,KAAK,CAAC;EACf,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,MAAM,GAAG,UAAU,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE;EACxE;EACA,EAAEG,WAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;EAChC;AACA;EACA,EAAE,IAAI,KAAK,GAAGJ,yBAAY,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;EAC7C,EAAE,MAAM,eAAe,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;EACzC,EAAE,MAAM,SAAS,GAAG,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;AAC/C;EACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;EAC5C,IAAI,SAAS,CAAC,CAAC,CAAC,GAAGQ,kBAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;EACnD,IAAI,KAAK,IAAI,CAAC,CAAC;EACf,GAAG;AACH;EACA,EAAE,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;EACrC,EAAE,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,GAAG,CAAC;EACtC,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;AACjC;EACA,EAAE,MAAM,SAAS,GAAGP,iBAAS,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;EACnD,EAAE,KAAK,IAAIA,iBAAS,CAAC,YAAY,CAAC;AAClC;EACA,EAAE,MAAM,eAAe,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;EACzC,EAAE,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,GAAG,CAAC;AAC7C;EACA,EAAE,IAAI,CAACK,oBAAO,CAAC,MAAM,CAAC,EAAE;EACxB,IAAI,MAAM,GAAG,IAAI,sBAAsB,CAAC;EACxC,MAAM,SAAS,EAAE,SAAS;EAC1B,KAAK,CAAC,CAAC;EACP,GAAG;AACH;EACA,EAAE,MAAM,CAAC,UAAU,GAAG,SAAS,CAAC;EAChC,EAAE,MAAM,CAAC,WAAW,GAAG,WAAW,CAAC;EACnC,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;EACrB,EAAE,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;EAC3B,EAAE,MAAM,CAAC,UAAU,GAAG,SAAS,CAAC;EAChC,EAAE,MAAM,CAAC,gBAAgB,GAAG,eAAe,CAAC;EAC5C,EAAE,MAAM,CAAC,YAAY,GAAG,WAAW,CAAC;AACpC;EACA,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC,CAAC;AACF;EACA,SAAS,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;EAC3C,EAAEE,kBAAU,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;EAC9C,EAAEA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EACvC,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC;AACD;EACA,SAAS,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE;EACtD,EAAE,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AAC7C;EACA;EACA,EAAE,MAAM,GAAGA,kBAAU,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;EAChD,EAAE,MAAM,GAAGA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAChD,EAAE,MAAM,GAAGA,kBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;EAChD,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC;AACD;EACA,MAAM,iBAAiB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC3C,MAAM,aAAa,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACvC,MAAM,cAAc,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACxC,MAAM,eAAe,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACzC,MAAM,QAAQ,GAAG,GAAG,CAAC;EACrB,MAAM,SAAS,GAAG,CAAC,GAAG,CAAC;EACvB,SAAS,wBAAwB;EACjC,EAAE,cAAc;EAChB,EAAE,YAAY;EACd,EAAE,SAAS;EACX,EAAE,UAAU;EACZ,EAAE,MAAM;EACR,EAAE;EACF,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC,SAAS,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;AACjE;EACA;EACA,EAAE,MAAM,UAAU,GAAG,gBAAgB;EACrC,IAAI,cAAc;EAClB,IAAI,YAAY;EAChB,IAAI,EAAE;EACN,IAAI,iBAAiB;EACrB,GAAG,CAAC;EACJ,EAAE,MAAM,MAAM,GAAG,gBAAgB,CAAC,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,aAAa,CAAC,CAAC;AAC/E;EACA;EACA,EAAE;EACF,IAAIH,iBAAU,CAAC,aAAa;EAC5B,MAAMG,kBAAU,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC;EACxC,MAAM,SAAS;EACf,MAAMH,iBAAU,CAAC,QAAQ;EACzB,KAAK;EACL,IAAI;EACJ,IAAI,MAAM,GAAGG,kBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;EACtD,IAAI,MAAM,GAAGA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAClD,IAAI,OAAO,MAAM,CAAC;EAClB,GAAG;AACH;EACA;EACA,EAAE,MAAM,GAAGA,kBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;EACtD,EAAE,MAAM,GAAGA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAChD;EACA;EACA,EAAE,MAAM,OAAO,GAAGA,kBAAU,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,cAAc,CAAC,CAAC;EAC/D,EAAE,IAAIA,kBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG,QAAQ,EAAE;EAClD,IAAI,MAAM,GAAGA,kBAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAC/C,GAAG;AACH;EACA,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC;AACD;EACA,MAAM,QAAQ,GAAGU,WAAK,CAAC,eAAe,CAACV,kBAAU,CAAC,IAAI,EAAEA,kBAAU,CAAC,MAAM,CAAC,CAAC;AAC3E;EACA,MAAM,qBAAqB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC/C,MAAM,mBAAmB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC7C,MAAM,gBAAgB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC1C,MAAM,iBAAiB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC3C,MAAM,mBAAmB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC7C,MAAM,mBAAmB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC7C,MAAM,oBAAoB,GAAG,IAAIC,oBAAY,EAAE,CAAC;EAChD,MAAM,oBAAoB,GAAG,IAAIA,oBAAY,EAAE,CAAC;EAChD,MAAM,+BAA+B,GAAG,IAAIA,oBAAY,EAAE,CAAC;EAC3D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,cAAc,GAAG,UAAU,sBAAsB,EAAE;EAC1E,EAAE,MAAM,mBAAmB,GAAG,CAAC,sBAAsB,CAAC,YAAY,CAAC;EACnE,EAAE,IAAI,IAAI,GAAG,sBAAsB,CAAC,IAAI,CAAC;EACzC,EAAE,MAAM,SAAS,GAAG,sBAAsB,CAAC,UAAU,CAAC;EACtD,EAAE,MAAM,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC;EACzD,EAAE,MAAM,OAAO,GAAG,sBAAsB,CAAC,OAAO,CAAC;EACjD,EAAE,MAAM,UAAU,GAAG,IAAI,WAAW,CAAC,sBAAsB,CAAC,gBAAgB,CAAC;EAC7E,IAAI,SAAS;EACb,GAAG,CAAC;AACJ;EACA,EAAE,MAAM,SAAS,GAAG,uBAAuB,CAAC;EAC5C,EAAE,MAAM,SAAS,GAAG,uBAAuB,CAAC;AAC5C;EACA,EAAE,IAAI,KAAK,CAAC;EACZ,EAAE,IAAI,CAAC,CAAC;AACR;EACA,EAAE,MAAM,SAAS,GAAG,sBAAsB,CAAC,UAAU,CAAC;EACtD,EAAE,MAAM,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;AAC3C;EACA,EAAE,IAAI,eAAe,KAAK,CAAC,EAAE;EAC7B,IAAI,IAAI,GAAG,KAAK,CAAC;EACjB,GAAG;AACH;EACA;EACA;EACA;EACA,EAAE,IAAI,EAAE,CAAC;EACT,EAAE,IAAI,EAAE,CAAC;EACT,EAAE,IAAI,EAAE,CAAC;EACT,EAAE,IAAI,EAAE,CAAC;EACT,EAAE,MAAM,SAAS,GAAG,IAAIQ,qCAAkB,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;EAC5E,EAAE,IAAI,YAAY,CAAC;EACnB,EAAE,IAAI,wBAAwB,CAAC;EAC/B,EAAE,IAAI,qBAAqB,CAAC;EAC5B,EAAE,MAAM,cAAc,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;EACxC,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;EAC5C,IAAI,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;EACtB,IAAI,EAAE,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1B,IAAI,YAAY,GAAGE,mCAAiB,CAAC,gBAAgB;EACrD,MAAM,EAAE;EACR,MAAM,EAAE;EACR,MAAM,QAAQ;EACd,MAAM,mBAAmB;EACzB,KAAK,CAAC;EACN,IAAI;EACJ,MAAMb,oBAAO,CAAC,YAAY,CAAC;EAC3B,MAAM,CAACE,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EACtE,MAAM,CAACG,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EACtE,MAAM;EACN,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKU,eAAO,CAAC,QAAQ,EAAE;EAC/D,QAAQ,cAAc,CAAC,IAAI,CAACP,kBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;EAC5D,OAAO,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKO,eAAO,CAAC,KAAK,EAAE;EACnE,QAAQ,qBAAqB,GAAG,SAAS,CAAC,uBAAuB;EACjE,UAAU,YAAY;EACtB,UAAU,oBAAoB;EAC9B,SAAS,CAAC,SAAS,CAAC;EACpB,QAAQ,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;EACzE,QAAQ,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;EACzE,QAAQ,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;EACvC,QAAQ,wBAAwB,GAAG,SAAS,CAAC,6BAA6B;EAC1E,UAAU,qBAAqB;EAC/B,UAAU,+BAA+B;EACzC,SAAS,CAAC;EACV,QAAQ,YAAY,GAAG,SAAS,CAAC,uBAAuB;EACxD,UAAU,wBAAwB;EAClC,UAAU,mBAAmB;EAC7B,SAAS,CAAC;EACV,QAAQ;EACR,UAAUT,oBAAO,CAAC,YAAY,CAAC;EAC/B,UAAU,CAACE,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EAC1E,UAAU,CAACG,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EAC1E,UAAU;EACV,UAAU,cAAc,CAAC,IAAI,CAACG,kBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;EAC9D,SAAS;EACT,OAAO;EACP,KAAK;EACL,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;EAC5B,GAAG;AACH;EACA,EAAE,IAAI,IAAI,EAAE;EACZ,IAAI,EAAE,GAAG,SAAS,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;EACxC,IAAI,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;EACtB,IAAI,YAAY,GAAGW,mCAAiB,CAAC,gBAAgB;EACrD,MAAM,EAAE;EACR,MAAM,EAAE;EACR,MAAM,QAAQ;EACd,MAAM,mBAAmB;EACzB,KAAK,CAAC;EACN,IAAI;EACJ,MAAMb,oBAAO,CAAC,YAAY,CAAC;EAC3B,MAAM,CAACE,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EACtE,MAAM,CAACG,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EACtE,MAAM;EACN,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKU,eAAO,CAAC,QAAQ,EAAE;EAC/D,QAAQ,cAAc,CAAC,IAAI,CAACP,kBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;EAC5D,OAAO,MAAM,IAAI,sBAAsB,CAAC,OAAO,KAAKO,eAAO,CAAC,KAAK,EAAE;EACnE,QAAQ,qBAAqB,GAAG,SAAS,CAAC,uBAAuB;EACjE,UAAU,YAAY;EACtB,UAAU,oBAAoB;EAC9B,SAAS,CAAC,SAAS,CAAC;EACpB,QAAQ,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;EACzE,QAAQ,EAAE,GAAG,SAAS,CAAC,uBAAuB,CAAC,EAAE,EAAE,oBAAoB,CAAC,CAAC;EACzE,QAAQ,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;EACvC,QAAQ,wBAAwB,GAAG,SAAS,CAAC,6BAA6B;EAC1E,UAAU,qBAAqB;EAC/B,UAAU,+BAA+B;EACzC,SAAS,CAAC;EACV,QAAQ,YAAY,GAAG,SAAS,CAAC,uBAAuB;EACxD,UAAU,wBAAwB;EAClC,UAAU,mBAAmB;EAC7B,SAAS,CAAC;EACV,QAAQ;EACR,UAAUT,oBAAO,CAAC,YAAY,CAAC;EAC/B,UAAU,CAACE,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EAC1E,UAAU,CAACG,kBAAU,CAAC,aAAa,CAAC,YAAY,EAAE,EAAE,EAAEH,iBAAU,CAAC,QAAQ,CAAC;EAC1E,UAAU;EACV,UAAU,cAAc,CAAC,IAAI,CAACG,kBAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;EAC9D,SAAS;EACT,OAAO;EACP,KAAK;EACL,GAAG;EACH,EAAE,IAAI,mBAAmB,GAAG,cAAc,CAAC,MAAM,CAAC;AAClD;EACA,EAAE,IAAI,aAAa,GAAG,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;EACrD,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE,EAAE;EAC5C,IAAI,MAAM,YAAY,GAAGC,oBAAY,CAAC,aAAa;EACnD,MAAM,cAAc,CAAC,CAAC,CAAC;EACvB,MAAM,SAAS;EACf,KAAK,CAAC;EACN,IAAI,YAAY,CAAC,MAAM,GAAG,GAAG,CAAC;EAC9B,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC;EACpC,GAAG;AACH;EACA,EAAE,aAAa,GAAGW,2CAAqB;EACvC,IAAI,aAAa;EACjB,IAAIX,oBAAY,CAAC,aAAa;EAC9B,GAAG,CAAC;EACJ,EAAE,mBAAmB,GAAG,aAAa,CAAC,MAAM,CAAC;AAC7C;EACA,EAAE,IAAI,mBAAmB,GAAG,CAAC,EAAE;EAC/B,IAAI,OAAO,SAAS,CAAC;EACrB,GAAG;AACH;EACA;EACA;EACA;EACA;EACA;EACA,EAAE,MAAM,kBAAkB,GAAG,EAAE,CAAC;EAChC,EAAE,MAAM,YAAY,GAAG,EAAE,CAAC;EAC1B,EAAE,MAAM,oBAAoB,GAAG,EAAE,CAAC;EAClC,EAAE,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC/B;EACA,EAAE,IAAI,cAAc,GAAG,qBAAqB,CAAC;EAC7C,EAAE,IAAI,YAAY,GAAG,mBAAmB,CAAC;EACzC,EAAE,IAAI,SAAS,GAAG,gBAAgB,CAAC;EACnC,EAAE,IAAI,UAAU,GAAG,iBAAiB,CAAC;EACrC,EAAE,IAAI,YAAY,GAAG,mBAAmB,CAAC;AACzC;EACA;EACA,EAAE,MAAM,iBAAiB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;EAC7C,EAAE,MAAM,gBAAgB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AAC5C;EACA,EAAE,MAAM,oBAAoB,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;EACtE,EAAE,cAAc,GAAG,WAAW;EAC9B,IAAI,SAAS;EACb,IAAI,oBAAoB;EACxB,IAAI,SAAS;EACb,IAAI,cAAc;EAClB,GAAG,CAAC;EACJ,EAAE,UAAU,GAAG,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;EAC/E,EAAE,YAAY,GAAG,WAAW;EAC5B,IAAI,SAAS;EACb,IAAI,iBAAiB;EACrB,IAAI,SAAS;EACb,IAAI,YAAY;EAChB,GAAG,CAAC;EACJ,EAAE,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,iBAAiB,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAC9E;EACA,EAAE,IAAI,IAAI,EAAE;EACZ,IAAI,YAAY,GAAG,wBAAwB;EAC3C,MAAM,cAAc;EACpB,MAAM,YAAY;EAClB,MAAM,SAAS;EACf,MAAM,UAAU;EAChB,MAAM,YAAY;EAClB,KAAK,CAAC;EACN,GAAG,MAAM;EACT,IAAI,YAAY,GAAG,kBAAkB;EACrC,MAAM,iBAAiB;EACvB,MAAM,gBAAgB;EACtB,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,YAAY;EAClB,KAAK,CAAC;EACN,GAAG;AACH;EACA,EAAED,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;EACjD,EAAEA,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,CAAC,CAAC,CAAC;EACzD,EAAEA,kBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,CAAC,CAAC,CAAC;EACnD,EAAE,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;EACtD,EAAE,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;AACvD;EACA,EAAE,kBAAkB;EACpB,IAAI,iBAAiB;EACrB,IAAI,gBAAgB;EACpB,IAAI,SAAS;EACb,IAAI,SAAS;EACb,IAAI,WAAW;EACf,IAAI,OAAO;EACX,IAAI,SAAS;EACb,IAAI,YAAY;EAChB,IAAI,oBAAoB;EACxB,IAAI,iBAAiB;EACrB,IAAI,kBAAkB;EACtB,GAAG,CAAC;AACJ;EACA;EACA,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;EAChD,IAAI,cAAc,GAAGA,kBAAU,CAAC,KAAK,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;EACpE,IAAI,YAAY,GAAGA,kBAAU,CAAC,KAAK,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;EAC9D,IAAI,MAAM,kBAAkB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;EAChD,IAAI,WAAW,CAAC,SAAS,EAAE,kBAAkB,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;EACrE,IAAI,WAAW,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;AACxE;EACA,IAAI,wBAAwB;EAC5B,MAAM,cAAc;EACpB,MAAM,YAAY;EAClB,MAAM,SAAS;EACf,MAAM,UAAU;EAChB,MAAM,YAAY;EAClB,KAAK,CAAC;AACN;EACA,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;EAChC,IAAIA,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;EACvD,IAAIA,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;EAC/D,IAAIA,kBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;EACzD,IAAI,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;EACzD,IAAI,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;AAC1D;EACA,IAAI,kBAAkB;EACtB,MAAM,aAAa,CAAC,CAAC,CAAC;EACtB,MAAM,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1B,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,WAAW;EACjB,MAAM,OAAO;EACb,MAAM,SAAS;EACf,MAAM,YAAY;EAClB,MAAM,oBAAoB;EAC1B,MAAM,iBAAiB;EACvB,MAAM,kBAAkB;EACxB,KAAK,CAAC;EACN,GAAG;AACH;EACA;EACA,EAAE,MAAM,eAAe,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;EACjE,EAAE,MAAM,kBAAkB,GAAG,aAAa,CAAC,mBAAmB,GAAG,CAAC,CAAC,CAAC;AACpE;EACA,EAAE,YAAY,GAAG,WAAW;EAC5B,IAAI,SAAS;EACb,IAAI,eAAe;EACnB,IAAI,SAAS;EACb,IAAI,YAAY;EAChB,GAAG,CAAC;EACJ,EAAE,SAAS,GAAG,WAAW,CAAC,SAAS,EAAE,eAAe,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;AAC5E;EACA,EAAE,IAAI,IAAI,EAAE;EACZ,IAAI,MAAM,mBAAmB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;EACjD,IAAI,cAAc,GAAG,WAAW;EAChC,MAAM,SAAS;EACf,MAAM,kBAAkB;EACxB,MAAM,SAAS;EACf,MAAM,cAAc;EACpB,KAAK,CAAC;EACN,IAAI,UAAU,GAAG,WAAW;EAC5B,MAAM,SAAS;EACf,MAAM,mBAAmB;EACzB,MAAM,SAAS;EACf,MAAM,UAAU;EAChB,KAAK,CAAC;AACN;EACA,IAAI,YAAY,GAAG,wBAAwB;EAC3C,MAAM,cAAc;EACpB,MAAM,YAAY;EAClB,MAAM,SAAS;EACf,MAAM,UAAU;EAChB,MAAM,YAAY;EAClB,KAAK,CAAC;EACN,GAAG,MAAM;EACT,IAAI,YAAY,GAAG,kBAAkB;EACrC,MAAM,kBAAkB;EACxB,MAAM,eAAe;EACrB,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,YAAY;EAClB,KAAK,CAAC;EACN,GAAG;AACH;EACA,EAAE,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;EAC9B,EAAEA,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;EACrD,EAAEA,kBAAU,CAAC,IAAI,CAAC,YAAY,EAAE,oBAAoB,EAAE,KAAK,CAAC,CAAC;EAC7D,EAAEA,kBAAU,CAAC,IAAI,CAAC,SAAS,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;EACvD,EAAE,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;EACpD,EAAE,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;AACrD;EACA,EAAE,IAAI,IAAI,EAAE;EACZ,IAAI,kBAAkB;EACtB,MAAM,eAAe;EACrB,MAAM,iBAAiB;EACvB,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,WAAW;EACjB,MAAM,OAAO;EACb,MAAM,SAAS;EACf,MAAM,YAAY;EAClB,MAAM,oBAAoB;EAC1B,MAAM,iBAAiB;EACvB,MAAM,kBAAkB;EACxB,KAAK,CAAC;EACN,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;EAChC,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;EAC5B,MAAM,YAAY,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;EAChD,MAAM,oBAAoB,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;EAChE,MAAM,iBAAiB,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;EAC1D,KAAK;EACL,IAAI,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;EACxD,IAAI,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;EACzD,GAAG;AACH;EACA,EAAE,OAAO,0BAA0B;EACnC,IAAI,IAAI;EACR,IAAI,UAAU;EACd,IAAI,oBAAoB;EACxB,IAAI,iBAAiB;EACrB,IAAI,YAAY;EAChB,IAAI,kBAAkB;EACtB,IAAI,mBAAmB;EACvB,GAAG,CAAC;EACJ,CAAC,CAAC;AACF;EACA;EACA;EACA;EACA,MAAM,oBAAoB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC9C,MAAM,cAAc,GAAG,IAAIa,eAAO,EAAE,CAAC;EACrC,MAAM,iBAAiB,GAAG,IAAIC,qBAAU,EAAE,CAAC;EAC3C,SAAS,UAAU,CAAC,iBAAiB,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,EAAE;EACvE,EAAE,MAAM,aAAa,GAAG,SAAS,CAAC,SAAS,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;AAChF;EACA,EAAE,MAAM,GAAG,GAAGd,kBAAU,CAAC,GAAG,CAAC,aAAa,EAAE,iBAAiB,CAAC,CAAC;EAC/D,EAAE,IAAI,GAAG,GAAG,iBAAiB,IAAI,GAAG,GAAG,iBAAiB,EAAE;EAC1D,IAAI,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,eAAe,CAAC,CAAC;EACnE,IAAI,MAAM,KAAK;EACf,MAAM,GAAG,GAAG,iBAAiB;EAC7B,UAAUH,iBAAU,CAAC,WAAW;EAChC,UAAU,CAACA,iBAAU,CAAC,WAAW,CAAC;EAClC,IAAI,MAAM,UAAU,GAAGiB,qBAAU,CAAC,aAAa;EAC/C,MAAM,QAAQ;EACd,MAAM,KAAK;EACX,MAAM,iBAAiB;EACvB,KAAK,CAAC;EACN,IAAI,MAAM,cAAc,GAAGD,eAAO,CAAC,cAAc,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;EAC9E,IAAIA,eAAO,CAAC,gBAAgB;EAC5B,MAAM,cAAc;EACpB,MAAM,iBAAiB;EACvB,MAAM,iBAAiB;EACvB,KAAK,CAAC;EACN,IAAI,OAAO,IAAI,CAAC;EAChB,GAAG;EACH,EAAE,OAAO,KAAK,CAAC;EACf,CAAC;AACD;EACA,MAAM,yBAAyB,GAAG,IAAIZ,oBAAY,EAAE,CAAC;EACrD,MAAM,uBAAuB,GAAG,IAAID,kBAAU,EAAE,CAAC;EACjD,MAAM,qBAAqB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC/C,SAAS,aAAa;EACtB,EAAE,UAAU;EACZ,EAAE,YAAY;EACd,EAAE,MAAM;EACR,EAAE,iBAAiB;EACnB,EAAE,MAAM;EACR,EAAE;EACF,EAAE,MAAM,QAAQ,GAAGC,oBAAY,CAAC,WAAW;EAC3C,IAAI,YAAY;EAChB,IAAI,UAAU,CAAC,UAAU;EACzB,IAAI,uBAAuB;EAC3B,GAAG,CAAC;EACJ,EAAE,IAAI,cAAc,GAAGD,kBAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,qBAAqB,CAAC,CAAC;EAC/E,EAAE,IAAI,UAAU,GAAG,KAAK,CAAC;AACzB;EACA,EAAE,MAAM,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC;EAC1C,EAAE,IAAI,0BAA0B,GAAG,SAAS,CAAC,uBAAuB;EACpE,IAAI,cAAc;EAClB,IAAI,yBAAyB;EAC7B,GAAG,CAAC;EACJ;EACA;EACA;EACA;EACA,EAAE;EACF,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,SAAS,GAAG,0BAA0B,CAAC,SAAS,CAAC;EAC3E,IAAIH,iBAAU,CAAC,WAAW;EAC1B,IAAI;EACJ,IAAI,UAAU,GAAG,IAAI,CAAC;EACtB,IAAI,cAAc,GAAGG,kBAAU,CAAC,QAAQ;EACxC,MAAM,QAAQ;EACd,MAAM,MAAM;EACZ,MAAM,qBAAqB;EAC3B,KAAK,CAAC;EACN,IAAI,0BAA0B,GAAG,SAAS,CAAC,uBAAuB;EAClE,MAAM,cAAc;EACpB,MAAM,yBAAyB;EAC/B,KAAK,CAAC;EACN,GAAG;AACH;EACA,EAAE,0BAA0B,CAAC,MAAM,GAAG,GAAG,CAAC;EAC1C,EAAE,MAAM,uBAAuB,GAAG,UAAU,CAAC,OAAO;EACpD,IAAI,0BAA0B;EAC9B,IAAI,MAAM;EACV,GAAG,CAAC;EACJ,EAAE,MAAM,GAAGA,kBAAU,CAAC,QAAQ;EAC9B,IAAI,uBAAuB;EAC3B,IAAI,iBAAiB;EACrB,IAAI,MAAM;EACV,GAAG,CAAC;EACJ,EAAE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;EACjB,EAAE,MAAM,GAAGA,kBAAU,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAChD,EAAE,IAAI,UAAU,EAAE;EAClB,IAAIA,kBAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EACtC,GAAG;EACH,EAAE,OAAO,MAAM,CAAC;EAChB,CAAC;AACD;EACA,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,SAAS,aAAa;EACtB,EAAE,MAAM;EACR,EAAE,GAAG;EACL,EAAE,SAAS;EACX,EAAE,SAAS;EACX,EAAE,kBAAkB;EACpB,EAAE,eAAe;EACjB,EAAE;EACF;EACA,EAAE,MAAM,kBAAkB,GAAGA,kBAAU,CAAC,QAAQ;EAChD,IAAI,GAAG;EACP,IAAI,MAAM;EACV,IAAI,yBAAyB;EAC7B,GAAG,CAAC;EACJ,EAAEA,kBAAU,CAAC,SAAS,CAAC,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;AAC/D;EACA,EAAE,MAAM,iBAAiB,GAAG,SAAS,GAAG,uBAAuB,CAAC;EAChE,EAAE,IAAI,kBAAkB,GAAGA,kBAAU,CAAC,gBAAgB;EACtD,IAAI,kBAAkB;EACtB,IAAI,iBAAiB;EACrB,IAAI,yBAAyB;EAC7B,GAAG,CAAC;EACJ,EAAEA,kBAAU,CAAC,GAAG,CAAC,MAAM,EAAE,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;AACjE;EACA,EAAE,MAAM,cAAc,GAAG,SAAS,GAAG,uBAAuB,CAAC;EAC7D,EAAE,kBAAkB,GAAGA,kBAAU,CAAC,gBAAgB;EAClD,IAAI,kBAAkB;EACtB,IAAI,cAAc;EAClB,IAAI,yBAAyB;EAC7B,GAAG,CAAC;EACJ,EAAEA,kBAAU,CAAC,GAAG,CAAC,GAAG,EAAE,kBAAkB,EAAE,eAAe,CAAC,CAAC;EAC3D,CAAC;AACD;EACA,MAAM,qBAAqB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC/C,SAAS,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE;EAC7B,EAAE,MAAM,iBAAiB,GAAGU,WAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;EACpE,EAAE,MAAM,eAAe,GAAGA,WAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;EAChE,EAAE,IAAI,MAAM,GAAG,qBAAqB,CAAC;EACrC;EACA,EAAE,IAAIb,iBAAU,CAAC,aAAa,CAAC,iBAAiB,EAAE,GAAG,EAAEA,iBAAU,CAAC,QAAQ,CAAC,EAAE;EAC7E,IAAI,MAAM,GAAG,SAAS,CAAC,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;EAC3C,IAAIG,kBAAU,CAAC,gBAAgB,CAAC,MAAM,EAAEH,iBAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;EACrE,IAAIG,kBAAU,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;EACzC,GAAG,MAAM;EACT,IAAIH,iBAAU,CAAC,aAAa,CAAC,eAAe,EAAE,GAAG,EAAEA,iBAAU,CAAC,QAAQ,CAAC;EACvE,IAAI;EACJ,IAAI,MAAM,GAAG,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;EAC3C,IAAIG,kBAAU,CAAC,gBAAgB,CAAC,MAAM,EAAEH,iBAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;EACrE,IAAIG,kBAAU,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;EACrC,GAAG;EACH,CAAC;AACD;EACA;EACA;EACA;EACA,SAAS,iBAAiB,CAAC,KAAK,EAAE,GAAG,EAAE;EACvC,EAAE,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;EAChD,EAAE,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;EAC5C,EAAE;EACF,IAAIH,iBAAU,CAAC,aAAa,CAAC,WAAW,EAAEA,iBAAU,CAAC,EAAE,EAAEA,iBAAU,CAAC,SAAS,CAAC;EAC9E,IAAI;EACJ,IAAI,MAAM,OAAO,GAAGA,iBAAU,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;EACnD,IAAI,KAAK,CAAC,SAAS,GAAG,OAAO,IAAI,WAAW,GAAGA,iBAAU,CAAC,SAAS,CAAC,CAAC;EACrE,IAAI,OAAO,CAAC,CAAC;EACb,GAAG,MAAM;EACT,IAAIA,iBAAU,CAAC,aAAa,CAAC,SAAS,EAAEA,iBAAU,CAAC,EAAE,EAAEA,iBAAU,CAAC,SAAS,CAAC;EAC5E,IAAI;EACJ,IAAI,MAAM,SAAS,GAAGA,iBAAU,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;EACvD,IAAI,GAAG,CAAC,SAAS,GAAG,SAAS,IAAI,SAAS,GAAGA,iBAAU,CAAC,SAAS,CAAC,CAAC;EACnE,IAAI,OAAO,CAAC,CAAC;EACb,GAAG;EACH,EAAE,OAAO,CAAC,CAAC;EACX,CAAC;AACD;EACA,MAAM,wBAAwB,GAAG,IAAII,oBAAY,EAAE,CAAC;EACpD,MAAM,sBAAsB,GAAG,IAAIA,oBAAY,EAAE,CAAC;AAClD;EACA,MAAM,sBAAsB,GAAG,IAAID,kBAAU,EAAE,CAAC;EAChD,MAAM,oBAAoB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC9C,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,MAAM,uBAAuB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACjD,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,MAAM,uBAAuB,GAAG,IAAIA,kBAAU,EAAE,CAAC;AACjD;EACA,MAAM,sBAAsB,GAAG;EAC/B,EAAE,wBAAwB;EAC1B,EAAE,sBAAsB;EACxB,CAAC,CAAC;EACF,MAAM,yBAAyB,GAAG,IAAIN,iBAAS,EAAE,CAAC;AAClD;EACA,MAAM,2BAA2B,GAAG,IAAIM,kBAAU,EAAE,CAAC;EACrD,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACnD,MAAM,8BAA8B,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACxD,MAAM,4BAA4B,GAAG,IAAIA,kBAAU,EAAE,CAAC;AACtD;EACA,MAAM,qBAAqB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC/C,MAAM,mBAAmB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC7C,MAAM,2BAA2B,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACrD,MAAM,yBAAyB,GAAG,IAAIA,kBAAU,EAAE,CAAC;AACnD;EACA,MAAM,aAAa,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACvC,MAAM,cAAc,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACxC,MAAM,YAAY,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACtC,MAAM,YAAY,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACtC,MAAM,uBAAuB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EACjD,MAAM,qBAAqB,GAAG,IAAIA,kBAAU,EAAE,CAAC;EAC/C,MAAM,aAAa,GAAG,IAAIe,mCAAiB,EAAE,CAAC;AAC9C;EACA,MAAM,eAAe,GAAG,IAAIA,mCAAiB,EAAE,CAAC;EAChD,MAAM,sBAAsB,GAAG,IAAIf,kBAAU,EAAE,CAAC;EAChD,MAAM,cAAc,GAAG,IAAIA,kBAAU,EAAE,CAAC;AACxC;EACA,MAAM,kBAAkB,GAAG,IAAIA,kBAAU,EAAE,CAAC;AAC5C;EACA,MAAM,sBAAsB,GAAG,CAAC,IAAIE,yBAAc,EAAE,EAAE,IAAIA,yBAAc,EAAE,CAAC,CAAC;AAC5E;EACA;EACA,MAAM,iBAAiB,GAAG;EAC1B,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,EAAE,CAAC;EACH,CAAC,CAAC;EACF,MAAM,wBAAwB,GAAG,iBAAiB,CAAC,MAAM,CAAC;AAC1D;EACA;EACA;EACA;EACA;EACA,SAAS,0BAA0B;EACnC,EAAE,IAAI;EACN,EAAE,UAAU;EACZ,EAAE,oBAAoB;EACtB,EAAE,iBAAiB;EACnB,EAAE,YAAY;EACd,EAAE,kBAAkB;EACpB,EAAE,mBAAmB;EACrB,EAAE;EACF,EAAE,IAAI,CAAC,CAAC;EACR,EAAE,IAAI,KAAK,CAAC;EACZ,EAAE,MAAM,SAAS,GAAG,UAAU,CAAC,UAAU,CAAC;AAC1C;EACA;EACA,EAAE,MAAM,YAAY,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;EAC3D,EAAE,MAAM,WAAW,GAAG,YAAY,GAAG,CAAC,CAAC;EACvC,EAAE,MAAM,aAAa,GAAG,WAAW,GAAG,CAAC,CAAC;EACxC,EAAE,MAAM,UAAU,GAAG,YAAY,GAAG,EAAE,CAAC;AACvC;EACA,EAAE,MAAM,OAAO;EACf,IAAI,WAAW,GAAG,KAAK;EACvB,QAAQ,IAAI,WAAW,CAAC,UAAU,CAAC;EACnC,QAAQ,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC;EACpC,EAAE,MAAM,cAAc,GAAG,IAAI,YAAY,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;AAC3D;EACA,EAAE,MAAM,wBAAwB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EACnE,EAAE,MAAM,wBAAwB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EACnE,EAAE,MAAM,4BAA4B,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EACvE,EAAE,MAAM,2CAA2C,GAAG,IAAI,YAAY;EACtE,IAAI,aAAa;EACjB,GAAG,CAAC;EACJ,EAAE,MAAM,6CAA6C,GAAG,IAAI,YAAY;EACxE,IAAI,aAAa;EACjB,GAAG,CAAC;AACJ;EACA,EAAE,IAAI,WAAW,CAAC;EAClB,EAAE,IAAI,gBAAgB,CAAC;EACvB,EAAE,IAAI,iBAAiB,CAAC;EACxB,EAAE,IAAI,uBAAuB,CAAC;AAC9B;EACA,EAAE,IAAI,mBAAmB,EAAE;EAC3B,IAAI,WAAW,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EAClD,IAAI,gBAAgB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EACvD,IAAI,iBAAiB,GAAG,IAAI,YAAY,CAAC,aAAa,CAAC,CAAC;EACxD,IAAI,uBAAuB,GAAG,IAAI,YAAY,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;EAChE,GAAG;AACH;EACA;EACA;EACA,EAAE,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;EAC5D,EAAE,IAAI,QAAQ,GAAG,GAAG,CAAC;AACrB;EACA,EAAE,MAAM,iBAAiB,GAAG,wBAAwB,CAAC;EACrD,EAAE,iBAAiB,CAAC,MAAM,GAAG,GAAG,CAAC;EACjC,EAAE,MAAM,eAAe,GAAG,sBAAsB,CAAC;EACjD,EAAE,eAAe,CAAC,MAAM,GAAG,GAAG,CAAC;AAC/B;EACA,EAAE,IAAI,qBAAqB,GAAG,sBAAsB,CAAC;EACrD,EAAE,IAAI,mBAAmB,GAAG,oBAAoB,CAAC;AACjD;EACA,EAAE,IAAI,mBAAmB,EAAE;EAC3B,IAAI,KAAK,GAAG,CAAC,CAAC;EACd,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,EAAE,CAAC,EAAE,EAAE;EAC9C;EACA,MAAM,iBAAiB,CAAC,QAAQ,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;EAC7D,MAAM,iBAAiB,CAAC,SAAS,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;EAClE,MAAM,eAAe,CAAC,QAAQ,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;EAC/D,MAAM,eAAe,CAAC,SAAS,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AAChE;EACA,MAAM,qBAAqB,GAAG,UAAU,CAAC,OAAO;EAChD,QAAQ,iBAAiB;EACzB,QAAQ,qBAAqB;EAC7B,OAAO,CAAC;EACR,MAAM,mBAAmB,GAAG,UAAU,CAAC,OAAO;EAC9C,QAAQ,eAAe;EACvB,QAAQ,mBAAmB;EAC3B,OAAO,CAAC;EACR,MAAM,QAAQ,IAAIF,kBAAU,CAAC,QAAQ;EACrC,QAAQ,qBAAqB;EAC7B,QAAQ,mBAAmB;EAC3B,OAAO,CAAC;EACR,MAAM,KAAK,IAAI,CAAC,CAAC;EACjB,KAAK;EACL,GAAG;AACH;EACA;EACA,EAAE,MAAM,eAAe,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;EACvD,EAAE,mBAAmB,GAAGA,kBAAU,CAAC,MAAM;EACzC,IAAI,iBAAiB;EACrB,IAAI,CAAC;EACL,IAAI,mBAAmB;EACvB,GAAG,CAAC;EACJ,EAAE,IAAI,QAAQ,GAAG,GAAG,CAAC;AACrB;EACA,EAAE,KAAK,GAAG,CAAC,CAAC;EACZ,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,EAAE;EACxC,IAAI,qBAAqB,GAAGA,kBAAU,CAAC,KAAK;EAC5C,MAAM,mBAAmB;EACzB,MAAM,qBAAqB;EAC3B,KAAK,CAAC;EACN,IAAI,mBAAmB,GAAGA,kBAAU,CAAC,MAAM;EAC3C,MAAM,iBAAiB;EACvB,MAAM,KAAK;EACX,MAAM,mBAAmB;EACzB,KAAK,CAAC;EACN,IAAI,QAAQ,IAAIA,kBAAU,CAAC,QAAQ,CAAC,qBAAqB,EAAE,mBAAmB,CAAC,CAAC;EAChF,IAAI,KAAK,IAAI,CAAC,CAAC;EACf,GAAG;AACH;EACA;EACA,EAAE,IAAI,CAAC,CAAC;EACR,EAAE,KAAK,GAAG,CAAC,CAAC;EACZ,EAAE,IAAI,kBAAkB,GAAG,CAAC,CAAC;EAC7B,EAAE,IAAI,eAAe,GAAG,CAAC,CAAC;EAC1B,EAAE,IAAI,eAAe,GAAG,CAAC,CAAC;EAC1B,EAAE,IAAI,eAAe,GAAG,CAAC,CAAC;EAC1B,EAAE,IAAI,WAAW,GAAG,KAAK,CAAC;AAC1B;EACA,EAAE,IAAI,SAAS,GAAGA,kBAAU,CAAC,MAAM;EACnC,IAAI,oBAAoB;EACxB,IAAI,CAAC;EACL,IAAI,uBAAuB;EAC3B,GAAG,CAAC;EACJ,EAAE,IAAI,MAAM,GAAGA,kBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,CAAC,EAAE,oBAAoB,CAAC,CAAC;EAC7E,EAAE,IAAI,iBAAiB,GAAGA,kBAAU,CAAC,MAAM;EAC3C,IAAI,YAAY;EAChB,IAAI,CAAC;EACL,IAAI,uBAAuB;EAC3B,GAAG,CAAC;AACJ;EACA,EAAE,IAAI,IAAI,EAAE;EACZ,IAAI,MAAM,YAAY,GAAGA,kBAAU,CAAC,MAAM;EAC1C,MAAM,oBAAoB;EAC1B,MAAM,oBAAoB,CAAC,MAAM,GAAG,CAAC;EACrC,MAAM,yBAAyB;EAC/B,KAAK,CAAC;EACN,IAAI,IAAI,UAAU,CAAC,iBAAiB,EAAE,YAAY,EAAE,SAAS,EAAE,MAAM,CAAC,EAAE;EACxE;EACA,MAAM,iBAAiB,GAAGA,kBAAU,CAAC,MAAM;EAC3C,QAAQ,iBAAiB;EACzB,QAAQ,iBAAiB;EACzB,OAAO,CAAC;EACR,KAAK;EACL,GAAG;AACH;EACA,EAAE,IAAI,aAAa,GAAG,GAAG,CAAC;EAC1B,EAAE,IAAI,aAAa,GAAG,GAAG,CAAC;AAC1B;EACA;EACA,EAAE,IAAI,UAAU,GAAG,GAAG,CAAC;AACvB;EACA,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;EACrC,IAAI,MAAM,WAAW,GAAGA,kBAAU,CAAC,KAAK,CAAC,SAAS,EAAE,yBAAyB,CAAC,CAAC;EAC/E,IAAI,MAAM,QAAQ,GAAGA,kBAAU,CAAC,KAAK,CAAC,MAAM,EAAE,sBAAsB,CAAC,CAAC;EACtE,IAAI,IAAI,mBAAmB,GAAGA,kBAAU,CAAC,KAAK;EAC9C,MAAM,iBAAiB;EACvB,MAAM,yBAAyB;EAC/B,KAAK,CAAC;AACN;EACA,IAAI,IAAI,WAAW,EAAE;EACrB,MAAM,mBAAmB,GAAGA,kBAAU,CAAC,MAAM;EAC7C,QAAQ,mBAAmB;EAC3B,QAAQ,mBAAmB;EAC3B,OAAO,CAAC;EACR,KAAK;AACL;EACA,IAAI,SAAS,GAAGA,kBAAU,CAAC,MAAM;EACjC,MAAM,oBAAoB;EAC1B,MAAM,KAAK;EACX,MAAM,uBAAuB;EAC7B,KAAK,CAAC;EACN,IAAI,MAAM,GAAGA,kBAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,KAAK,EAAE,oBAAoB,CAAC,CAAC;EAC/E,IAAI,iBAAiB,GAAGA,kBAAU,CAAC,MAAM;EACzC,MAAM,YAAY;EAClB,MAAM,KAAK;EACX,MAAM,uBAAuB;EAC7B,KAAK,CAAC;AACN;EACA,IAAI,WAAW,GAAG,UAAU,CAAC,iBAAiB,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AAChF;EACA;EACA,IAAI,iBAAiB,CAAC,QAAQ,GAAG,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;EACxE,IAAI,iBAAiB,CAAC,SAAS,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;EAC7E,IAAI,eAAe,CAAC,QAAQ,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;EAC1E,IAAI,eAAe,CAAC,SAAS,GAAG,kBAAkB,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;EAC3E,IAAI,IAAI,OAAO,CAAC;EAChB,IAAI,IAAI,KAAK,CAAC;EACd,IAAI,IAAI,qBAAqB,CAAC;EAC9B,IAAI,IAAI,mBAAmB,CAAC;AAC5B;EACA,IAAI,IAAI,mBAAmB,EAAE;EAC7B,MAAM,MAAM,WAAW,GAAG,iBAAiB,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;EAChF,MAAM,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC;EAC7E,MAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,eAAe,EAAE,mBAAmB,CAAC,CAAC;EACvE,MAAM,MAAM,WAAW,GAAG,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;EAC5E,MAAM,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9C;EACA,MAAM,qBAAqB,GAAG,2BAA2B,CAAC;EAC1D,MAAM,mBAAmB,GAAG,yBAAyB,CAAC;EACtD,MAAM;EACN,QAAQ,WAAW,KAAK,CAAC;EACzB,QAAQA,kBAAU,CAAC,GAAG,CAAC,WAAW,EAAEA,kBAAU,CAAC,MAAM,CAAC,GAAG,iBAAiB;EAC1E,QAAQ;EACR;EACA;EACA;EACA,QAAQ,qBAAqB,GAAG,aAAa;EAC7C,UAAU,UAAU;EACpB,UAAU,iBAAiB;EAC3B,UAAU,mBAAmB;EAC7B,UAAU,OAAO;EACjB,UAAU,2BAA2B;EACrC,SAAS,CAAC;EACV,QAAQ,mBAAmB,GAAG,aAAa;EAC3C,UAAU,UAAU;EACpB,UAAU,eAAe;EACzB,UAAU,iBAAiB;EAC3B,UAAU,KAAK;EACf,UAAU,yBAAyB;EACnC,SAAS,CAAC;EACV,OAAO,MAAM,IAAI,WAAW,KAAK,CAAC,EAAE;EACpC;EACA,QAAQ,mBAAmB,GAAG,aAAa;EAC3C,UAAU,UAAU;EACpB,UAAU,eAAe;EACzB,UAAU,iBAAiB;EAC3B,UAAU,KAAK;EACf,UAAU,yBAAyB;EACnC,SAAS,CAAC;EACV,QAAQ,qBAAqB,CAAC,CAAC,GAAG,GAAG,CAAC;EACtC;EACA;EACA,QAAQ,qBAAqB,CAAC,CAAC,GAAGH,iBAAU,CAAC,IAAI;EACjD,UAAU,iBAAiB,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,SAAS,CAAC;EAC3E,SAAS,CAAC;EACV,QAAQ,qBAAqB,CAAC,CAAC,GAAG,GAAG,CAAC;EACtC,OAAO,MAAM;EACb;EACA,QAAQ,qBAAqB,GAAG,aAAa;EAC7C,UAAU,UAAU;EACpB,UAAU,iBAAiB;EAC3B,UAAU,mBAAmB;EAC7B,UAAU,OAAO;EACjB,UAAU,2BAA2B;EACrC,SAAS,CAAC;EACV,QAAQ,mBAAmB,CAAC,CAAC,GAAG,GAAG,CAAC;EACpC;EACA;EACA,QAAQ,mBAAmB,CAAC,CAAC,GAAGA,iBAAU,CAAC,IAAI;EAC/C,UAAU,iBAAiB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS;EACjE,SAAS,CAAC;EACV,QAAQ,mBAAmB,CAAC,CAAC,GAAG,GAAG,CAAC;EACpC,OAAO;EACP,KAAK;AACL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;EACA;EACA,IAAI,MAAM,eAAe,GAAGG,kBAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;AAClE;EACA,IAAI,MAAM,YAAY,GAAGe,mCAAiB,CAAC,aAAa;EACxD,MAAM,WAAW;EACjB,MAAM,aAAa;EACnB,KAAK,CAAC;EACN,IAAI,MAAM,aAAa,GAAGf,kBAAU,CAAC,QAAQ;EAC7C,MAAM,SAAS;EACf,MAAM,WAAW;EACjB,MAAM,aAAa;EACnB,KAAK,CAAC;EACN,IAAI,MAAM,OAAO,GAAGA,kBAAU,CAAC,SAAS,CAAC,aAAa,EAAE,YAAY,CAAC,CAAC;AACtE;EACA,IAAI,IAAI,OAAO,GAAGA,kBAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;EAC7E,IAAI,OAAO,GAAGA,kBAAU,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;EACrD,IAAI,IAAI,WAAW,GAAGA,kBAAU,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC,CAAC;EACvE,IAAI,WAAW,GAAGA,kBAAU,CAAC,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;AACjE;EACA,IAAI,IAAI,gBAAgB,GAAGA,kBAAU,CAAC,KAAK;EAC3C,MAAM,OAAO;EACb,MAAM,mBAAmB;EACzB,MAAM,uBAAuB;EAC7B,KAAK,CAAC;EACN,IAAI,gBAAgB,GAAGA,kBAAU,CAAC,SAAS,CAAC,gBAAgB,EAAE,gBAAgB,CAAC,CAAC;AAChF;EACA,IAAI,IAAI,KAAK,GAAGA,kBAAU,CAAC,QAAQ,CAAC,MAAM,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;EACrE,IAAI,KAAK,GAAGA,kBAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;EAC/C,IAAI,IAAI,cAAc,GAAGA,kBAAU,CAAC,KAAK;EACzC,MAAM,iBAAiB;EACvB,MAAM,KAAK;EACX,MAAM,qBAAqB;EAC3B,KAAK,CAAC;EACN,IAAI,cAAc,GAAGA,kBAAU,CAAC,SAAS,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;AAC1E;EACA,IAAI,MAAM,wBAAwB,GAAG,eAAe,GAAG,QAAQ,CAAC;EAChE,IAAI,MAAM,wBAAwB,GAAG,aAAa,GAAG,QAAQ,CAAC;AAC9D;EACA;EACA,IAAI,IAAI,eAAe,GAAG,GAAG,CAAC;EAC9B,IAAI,IAAI,cAAc,CAAC;EACvB,IAAI,IAAI,eAAe,CAAC;EACxB,IAAI,IAAI,OAAO,CAAC;EAChB,IAAI,IAAI,wBAAwB,GAAG,GAAG,CAAC;EACvC,IAAI,IAAI,wBAAwB,GAAG,GAAG,CAAC;EACvC,IAAI,IAAI,mBAAmB,EAAE;EAC7B,MAAM,eAAe,GAAGA,kBAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC5D;EACA,MAAM,cAAc,GAAGe,mCAAiB,CAAC,aAAa;EACtD,QAAQ,OAAO;EACf,QAAQ,eAAe;EACvB,OAAO,CAAC;EACR,MAAM,eAAe,GAAGf,kBAAU,CAAC,QAAQ;EAC3C,QAAQ,KAAK;EACb,QAAQ,OAAO;EACf,QAAQ,sBAAsB;EAC9B,OAAO,CAAC;AACR;EACA;EACA;EACA,MAAM,OAAO,GAAGA,kBAAU,CAAC,SAAS,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;EACtE,MAAM,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;EAC7B,MAAM,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;EAC5B,MAAM,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;AACxB;EACA,MAAM,wBAAwB,GAAG,eAAe,GAAG,QAAQ,CAAC;EAC5D,MAAM,wBAAwB,GAAG,aAAa,GAAG,QAAQ,CAAC;EAC1D,KAAK;EACL;EACA,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;EAC5B,MAAM,MAAM,SAAS,GAAG,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;EAChD,MAAM,MAAM,SAAS,GAAG,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;EAChD,MAAM,MAAM,MAAM,GAAG,SAAS,GAAG,CAAC,CAAC;AACnC;EACA;EACA;EACA,MAAM,MAAM,cAAc,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC;EAChD,MAAM,MAAM,aAAa;EACzB,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC;AAC9D;EACA;EACA,MAAMA,kBAAU,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,wBAAwB,EAAE,SAAS,CAAC,CAAC;EAC9E,MAAM,wBAAwB,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AACzD;EACA,MAAMA,kBAAU,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,wBAAwB,EAAE,SAAS,CAAC,CAAC;EAC7E,MAAM,wBAAwB,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AACzD;EACA,MAAMA,kBAAU,CAAC,IAAI;EACrB,QAAQ,gBAAgB;EACxB,QAAQ,4BAA4B;EACpC,QAAQ,SAAS;EACjB,OAAO,CAAC;EACR,MAAM,4BAA4B,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;AAC7D;EACA,MAAMA,kBAAU,CAAC,IAAI;EACrB,QAAQ,cAAc;EACtB,QAAQ,2CAA2C;EACnD,QAAQ,SAAS;EACjB,OAAO,CAAC;EACR,MAAM,2CAA2C,CAAC,MAAM,CAAC;EACzD,QAAQ,wBAAwB,GAAG,cAAc,CAAC;AAClD;EACA,MAAMA,kBAAU,CAAC,IAAI;EACrB,QAAQ,WAAW;EACnB,QAAQ,6CAA6C;EACrD,QAAQ,SAAS;EACjB,OAAO,CAAC;AACR;EACA,MAAM,IAAI,qBAAqB,GAAG,wBAAwB,GAAG,aAAa,CAAC;EAC3E,MAAM,IAAI,qBAAqB,KAAK,GAAG,IAAI,aAAa,GAAG,GAAG,EAAE;EAChE,QAAQ,qBAAqB,GAAG,GAAG,CAAC;EACpC,OAAO;EACP,MAAM,6CAA6C;EACnD,QAAQ,MAAM;EACd,OAAO,GAAG,qBAAqB,CAAC;AAChC;EACA;EACA,MAAM,IAAI,mBAAmB,EAAE;EAC/B,QAAQ,WAAW,CAAC,SAAS,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;EACvD,QAAQ,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;EAC3D,QAAQ,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1D,QAAQ,WAAW,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1D;EACA,QAAQ,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC;EAChE,QAAQ,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,qBAAqB,CAAC,CAAC,CAAC;EACnE,QAAQ,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,mBAAmB,CAAC,CAAC,CAAC;EACjE,QAAQ,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC;AAClE;EACA,QAAQ,gBAAgB,CAAC,SAAS,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;EACxD,QAAQ,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;EAC5D,QAAQ,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;EACpD,QAAQ,gBAAgB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AACpD;EACA,QAAQ,uBAAuB,CAAC,SAAS,CAAC;EAC1C,UAAU,wBAAwB,GAAG,cAAc,CAAC;AACpD;EACA,QAAQ,qBAAqB,GAAG,wBAAwB,GAAG,aAAa,CAAC;EACzE,QAAQ,IAAI,qBAAqB,KAAK,GAAG,IAAI,aAAa,GAAG,GAAG,EAAE;EAClE,UAAU,qBAAqB,GAAG,GAAG,CAAC;EACtC,SAAS;EACT,QAAQ,uBAAuB,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,qBAAqB,CAAC;EACvE,OAAO;EACP,KAAK;AACL;EACA;EACA,IAAI,MAAM,uBAAuB,GAAG,8BAA8B,CAAC;EACnE,IAAI,MAAM,qBAAqB,GAAG,4BAA4B,CAAC;EAC/D,IAAI,MAAM,oBAAoB,GAAG,2BAA2B,CAAC;EAC7D,IAAI,MAAM,kBAAkB,GAAG,yBAAyB,CAAC;AACzD;EACA,IAAI,MAAM,mBAAmB,GAAGN,iBAAS,CAAC,qBAAqB;EAC/D,MAAM,sBAAsB;EAC5B,MAAM,yBAAyB;EAC/B,KAAK,CAAC;EACN,IAAI,MAAM,aAAa,GAAGsB,2BAAyB,CAAC,wBAAwB;EAC5E,MAAM,mBAAmB;EACzB,MAAM,SAAS;EACf,KAAK,CAAC;EACN,IAAI,MAAM,SAAS,GAAG,aAAa,CAAC,oBAAoB,CAAC;EACzD,IAAI,MAAM,SAAS,GAAG,aAAa,CAAC,oBAAoB,CAAC;AACzD;EACA,IAAI,UAAU,IAAI,SAAS,CAAC;EAC5B,IAAI,UAAU,IAAI,SAAS,CAAC;AAC5B;EACA,IAAI,aAAa;EACjB,MAAM,WAAW;EACjB,MAAM,QAAQ;EACd,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,uBAAuB;EAC7B,MAAM,oBAAoB;EAC1B,KAAK,CAAC;EACN,IAAI,aAAa;EACjB,MAAM,SAAS;EACf,MAAM,MAAM;EACZ,MAAM,SAAS;EACf,MAAM,SAAS;EACf,MAAM,qBAAqB;EAC3B,MAAM,kBAAkB;EACxB,KAAK,CAAC;AACN;EACA;EACA,IAAI,IAAI,WAAW,GAAGhB,kBAAU,CAAC,gBAAgB;EACjD,MAAM,WAAW;EACjB,MAAMH,iBAAU,CAAC,QAAQ;EACzB,MAAM,kBAAkB;EACxB,KAAK,CAAC;EACN,IAAIG,kBAAU,CAAC,GAAG;EAClB,MAAM,uBAAuB;EAC7B,MAAM,WAAW;EACjB,MAAM,uBAAuB;EAC7B,KAAK,CAAC;EACN,IAAIA,kBAAU,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,EAAE,qBAAqB,CAAC,CAAC;EAC9E,IAAIA,kBAAU,CAAC,GAAG,CAAC,oBAAoB,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;EAC5E,IAAIA,kBAAU,CAAC,GAAG,CAAC,kBAAkB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;AACxE;EACA;EACA,IAAI,OAAO,CAAC,uBAAuB,EAAE,qBAAqB,CAAC,CAAC;EAC5D,IAAI,OAAO,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;AACtD;EACA,IAAIA,kBAAU,CAAC,IAAI,CAAC,uBAAuB,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC;EAC9E,IAAIA,kBAAU,CAAC,IAAI,CAAC,qBAAqB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;EAChF,IAAIA,kBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;EAC7E,IAAIA,kBAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;AAC/E;EACA,IAAI,WAAW,GAAGA,kBAAU,CAAC,gBAAgB;EAC7C,MAAM,WAAW;EACjB,MAAM,CAAC,GAAG,GAAGH,iBAAU,CAAC,QAAQ;EAChC,MAAM,kBAAkB;EACxB,KAAK,CAAC;EACN,IAAIG,kBAAU,CAAC,GAAG;EAClB,MAAM,uBAAuB;EAC7B,MAAM,WAAW;EACjB,MAAM,uBAAuB;EAC7B,KAAK,CAAC;EACN,IAAIA,kBAAU,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,EAAE,qBAAqB,CAAC,CAAC;EAC9E,IAAIA,kBAAU,CAAC,GAAG,CAAC,oBAAoB,EAAE,WAAW,EAAE,oBAAoB,CAAC,CAAC;EAC5E,IAAIA,kBAAU,CAAC,GAAG,CAAC,kBAAkB,EAAE,WAAW,EAAE,kBAAkB,CAAC,CAAC;AACxE;EACA,IAAI,OAAO,CAAC,uBAAuB,EAAE,qBAAqB,CAAC,CAAC;EAC5D,IAAI,OAAO,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;AACtD;EACA,IAAIA,kBAAU,CAAC,IAAI;EACnB,MAAM,uBAAuB;EAC7B,MAAM,cAAc;EACpB,MAAM,eAAe,GAAG,EAAE;EAC1B,KAAK,CAAC;EACN,IAAIA,kBAAU,CAAC,IAAI;EACnB,MAAM,qBAAqB;EAC3B,MAAM,cAAc;EACpB,MAAM,eAAe,GAAG,EAAE;EAC1B,KAAK,CAAC;EACN,IAAIA,kBAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;EAC9E,IAAIA,kBAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,cAAc,EAAE,eAAe,GAAG,EAAE,CAAC,CAAC;AAChF;EACA,IAAI,kBAAkB,IAAI,CAAC,CAAC;EAC5B,IAAI,KAAK,IAAI,CAAC,CAAC;AACf;EACA,IAAI,eAAe,IAAI,EAAE,CAAC;EAC1B,IAAI,eAAe,IAAI,EAAE,CAAC;EAC1B,IAAI,eAAe,IAAI,EAAE,CAAC;AAC1B;EACA,IAAI,aAAa,IAAI,eAAe,CAAC;EACrC,IAAI,aAAa,IAAI,eAAe,CAAC;EACrC,GAAG;AACH;EACA,EAAE,KAAK,GAAG,CAAC,CAAC;EACZ,EAAE,IAAI,WAAW,GAAG,CAAC,CAAC;EACtB,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;EACrC,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,wBAAwB,EAAE,CAAC,EAAE,EAAE;EACnD,MAAM,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,iBAAiB,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;EAC9D,KAAK;EACL,IAAI,WAAW,IAAI,CAAC,CAAC;EACrB,IAAI,KAAK,IAAI,wBAAwB,CAAC;EACtC,GAAG;AACH;EACA,EAAE,MAAM,eAAe,GAAG,sBAAsB,CAAC;EACjD,EAAEE,yBAAc,CAAC,YAAY;EAC7B,IAAI,oBAAoB;EACxB,IAAIF,kBAAU,CAAC,IAAI;EACnB,IAAI,CAAC;EACL,IAAI,eAAe,CAAC,CAAC,CAAC;EACtB,GAAG,CAAC;EACJ,EAAEE,yBAAc,CAAC,YAAY;EAC7B,IAAI,iBAAiB;EACrB,IAAIF,kBAAU,CAAC,IAAI;EACnB,IAAI,CAAC;EACL,IAAI,eAAe,CAAC,CAAC,CAAC;EACtB,GAAG,CAAC;EACJ,EAAE,MAAM,cAAc,GAAGE,yBAAc,CAAC,mBAAmB,CAAC,eAAe,CAAC,CAAC;AAC7E;EACA;EACA,EAAE,cAAc,CAAC,MAAM,IAAI,UAAU,IAAI,YAAY,GAAG,GAAG,CAAC,CAAC;AAC7D;EACA,EAAE,MAAM,UAAU,GAAG;EACrB,IAAI,QAAQ,EAAE,IAAIe,mCAAiB,CAAC;EACpC,MAAM,iBAAiB,EAAEC,mCAAiB,CAAC,MAAM;EACjD,MAAM,sBAAsB,EAAE,CAAC;EAC/B,MAAM,SAAS,EAAE,KAAK;EACtB,MAAM,MAAM,EAAE,cAAc;EAC5B,KAAK,CAAC;EACN,IAAI,wBAAwB,EAAE,wBAAwB;EACtD,MAAM,wBAAwB;EAC9B,KAAK;EACL,IAAI,wBAAwB,EAAE,wBAAwB;EACtD,MAAM,wBAAwB;EAC9B,KAAK;EACL,IAAI,4BAA4B,EAAE,wBAAwB;EAC1D,MAAM,4BAA4B;EAClC,KAAK;EACL,IAAI,2CAA2C,EAAE,wBAAwB;EACzE,MAAM,2CAA2C;EACjD,KAAK;EACL,IAAI,6CAA6C,EAAE,wBAAwB;EAC3E,MAAM,6CAA6C;EACnD,KAAK;EACL,GAAG,CAAC;AACJ;EACA,EAAE,IAAI,mBAAmB,EAAE;EAC3B,IAAI,UAAU,CAAC,WAAW,GAAG,wBAAwB,CAAC,WAAW,CAAC,CAAC;EACnE,IAAI,UAAU,CAAC,gBAAgB,GAAG,wBAAwB,CAAC,gBAAgB,CAAC,CAAC;EAC7E,IAAI,UAAU,CAAC,iBAAiB,GAAG,wBAAwB,CAAC,iBAAiB,CAAC,CAAC;EAC/E,IAAI,UAAU,CAAC,uBAAuB,GAAG,IAAID,mCAAiB,CAAC;EAC/D,MAAM,iBAAiB,EAAEC,mCAAiB,CAAC,KAAK;EAChD,MAAM,sBAAsB,EAAE,CAAC;EAC/B,MAAM,SAAS,EAAE,KAAK;EACtB,MAAM,MAAM,EAAE,uBAAuB;EACrC,KAAK,CAAC,CAAC;EACP,GAAG;AACH;EACA,EAAE,OAAO,IAAIC,0BAAQ,CAAC;EACtB,IAAI,UAAU,EAAE,UAAU;EAC1B,IAAI,OAAO,EAAE,OAAO;EACpB,IAAI,cAAc,EAAE,cAAc;EAClC,GAAG,CAAC,CAAC;EACL,CAAC;AACD;EACA,SAAS,wBAAwB,CAAC,UAAU,EAAE;EAC9C,EAAE,OAAO,IAAIF,mCAAiB,CAAC;EAC/B,IAAI,iBAAiB,EAAEC,mCAAiB,CAAC,KAAK;EAC9C,IAAI,sBAAsB,EAAE,CAAC;EAC7B,IAAI,SAAS,EAAE,KAAK;EACpB,IAAI,MAAM,EAAE,UAAU;EACtB,GAAG,CAAC,CAAC;EACL,CAAC;AACD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,sBAAsB,CAAC,cAAc,GAAG,aAAa;;ECpnDrD,SAAS,4BAA4B,CAAC,sBAAsB,EAAE,MAAM,EAAE;EACtE,EAAE,OAAOF,2BAAyB,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,YAAY;EACjE,IAAI,IAAIlB,oBAAO,CAAC,MAAM,CAAC,EAAE;EACzB,MAAM,sBAAsB,GAAG,sBAAsB,CAAC,MAAM;EAC5D,QAAQ,sBAAsB;EAC9B,QAAQ,MAAM;EACd,OAAO,CAAC;EACR,KAAK;EACL,IAAI,OAAO,sBAAsB,CAAC,cAAc,CAAC,sBAAsB,CAAC,CAAC;EACzE,GAAG,CAAC,CAAC;EACL;;;;;;;;"}